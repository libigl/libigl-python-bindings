<!doctype html><html lang="en" class="no-js"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="description" content="Simple Python geometry processing library"><link rel="canonical" href="https://libigl.github.io/igl_docs/"><meta name="lang:clipboard.copy" content="Copy to clipboard"><meta name="lang:clipboard.copied" content="Copied to clipboard"><meta name="lang:search.language" content="en"><meta name="lang:search.pipeline.stopwords" content="True"><meta name="lang:search.pipeline.trimmer" content="True"><meta name="lang:search.result.none" content="No matching documents"><meta name="lang:search.result.one" content="1 matching document"><meta name="lang:search.result.other" content="# matching documents"><meta name="lang:search.tokenizer" content="[\s\-]+"><link rel="shortcut icon" href="../favicon.ico"><meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.3.0"><title>Docs - igl</title><link rel="stylesheet" href="../assets/stylesheets/application.4031d38b.css"><link rel="stylesheet" href="../assets/stylesheets/application-palette.224b79ff.css"><meta name="theme-color" content="#03a9f4"><script src="../assets/javascripts/modernizr.74668098.js"></script><link href="https://fonts.gstatic.com" rel="preconnect" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=swap"><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link rel="stylesheet" href="../assets/fonts/material-icons.css"></head><body dir="ltr" data-md-color-primary="light-blue" data-md-color-accent="blue"><svg class="md-svg"><defs><svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg></defs></svg> <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off"> <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off"> <label class="md-overlay" data-md-component="overlay" for="__drawer"></label><a href="#functions" tabindex="1" class="md-skip">Skip to content </a><header class="md-header" data-md-component="header"><nav class="md-header-nav md-grid"><div class="md-flex"><div class="md-flex__cell md-flex__cell--shrink"><a href="https://libigl.github.io/" title="igl" class="md-header-nav__button md-logo"><i class="md-icon"> </i></a></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label></div><div class="md-flex__cell md-flex__cell--stretch"><div class="md-flex__ellipsis md-header-nav__title" data-md-component="title"><span class="md-header-nav__topic">igl</span><span class="md-header-nav__topic">Docs</span></div></div><div class="md-flex__cell md-flex__cell--shrink"></div><div class="md-flex__cell md-flex__cell--shrink"><div class="md-header-nav__source"><a href="https://github.com/geometryprocessing/libigl-python-bindings/" title="Go to repository" class="md-source" data-md-source="github"><div class="md-source__icon"><svg viewBox="0 0 24 24" width="24" height="24"><use xlink:href="#__github" width="24" height="24"></use></svg></div><div class="md-source__repository">libigl-python-bindings</div></a></div></div></div></nav></header><div class="md-container"><main class="md-main"><div class="md-main__inner md-grid" data-md-component="container"><div class="md-sidebar md-sidebar--primary" data-md-component="navigation"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--primary" data-md-level="0"><label class="md-nav__title md-nav__title--site" for="__drawer"><a href="https://libigl.github.io/" title="igl" class="md-nav__button md-logo"><i class="md-icon"> </i></a>igl</label><div class="md-nav__source"><a href="https://github.com/geometryprocessing/libigl-python-bindings/" title="Go to repository" class="md-source" data-md-source="github"><div class="md-source__icon"><svg viewBox="0 0 24 24" width="24" height="24"><use xlink:href="#__github" width="24" height="24"></use></svg></div><div class="md-source__repository">libigl-python-bindings</div></a></div><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href=".." title="Home" class="md-nav__link">Home</a></li><li class="md-nav__item"><a href="../tutorials/" title="Tutorial" class="md-nav__link">Tutorial</a></li><li class="md-nav__item md-nav__item--active"><input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc"><label class="md-nav__link md-nav__link--active" for="__toc">Docs</label><a href="./" title="Docs" class="md-nav__link md-nav__link--active">Docs</a><nav class="md-nav md-nav--secondary"><label class="md-nav__title" for="__toc">Table of contents</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="#functions" title="Functions" class="md-nav__link">Functions</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#adjacency_listf-array" title="adjacency_list(f: array)" class="md-nav__link">adjacency_list(f: array)</a></li><li class="md-nav__item"><a href="#adjacency_matrixf-array" title="adjacency_matrix(f: array)" class="md-nav__link">adjacency_matrix(f: array)</a></li><li class="md-nav__item"><a href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int" title="ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int)" class="md-nav__link">ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int)</a></li><li class="md-nav__item"><a href="#arap_linear_blockv-array-f-array-d-int-energy-int" title="arap_linear_block(v: array, f: array, d: int, energy: int)" class="md-nav__link">arap_linear_block(v: array, f: array, d: int, energy: int)</a></li><li class="md-nav__item"><a href="#arap_linear_block_elementsv-array-f-array-d-int" title="arap_linear_block_elements(v: array, f: array, d: int)" class="md-nav__link">arap_linear_block_elements(v: array, f: array, d: int)</a></li><li class="md-nav__item"><a href="#arap_linear_block_spokesv-array-f-array-d-int" title="arap_linear_block_spokes(v: array, f: array, d: int)" class="md-nav__link">arap_linear_block_spokes(v: array, f: array, d: int)</a></li><li class="md-nav__item"><a href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int" title="arap_linear_block_spokes_and_rims(v: array, f: array, d: int)" class="md-nav__link">arap_linear_block_spokes_and_rims(v: array, f: array, d: int)</a></li><li class="md-nav__item"><a href="#arap_rhsv-array-f-array-d-int-energy-int" title="arap_rhs(v: array, f: array, d: int, energy: int)" class="md-nav__link">arap_rhs(v: array, f: array, d: int, energy: int)</a></li><li class="md-nav__item"><a href="#average_onto_verticesv-array-f-array-s-array" title="average_onto_vertices(v: array, f: array, s: array)" class="md-nav__link">average_onto_vertices(v: array, f: array, s: array)</a></li><li class="md-nav__item"><a href="#avg_edge_lengthv-array-f-array-float" title="avg_edge_length(v: array, f: array) -&gt; float" class="md-nav__link">avg_edge_length(v: array, f: array) -&gt; float</a></li><li class="md-nav__item"><a href="#barycenterv-array-f-array" title="barycenter(v: array, f: array)" class="md-nav__link">barycenter(v: array, f: array)</a></li><li class="md-nav__item"><a href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array" title="barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array)" class="md-nav__link">barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array)</a></li><li class="md-nav__item"><a href="#barycentric_coordinates_trip-array-a-array-b-array-c-array" title="barycentric_coordinates_tri(p: array, a: array, b: array, c: array)" class="md-nav__link">barycentric_coordinates_tri(p: array, a: array, b: array, c: array)</a></li><li class="md-nav__item"><a href="#bfsa-sparse_matrix-s-int" title="bfs(A: sparse_matrix, s: int)" class="md-nav__link">bfs(A: sparse_matrix, s: int)</a></li><li class="md-nav__item"><a href="#bfs_orientf-array" title="bfs_orient(f: array)" class="md-nav__link">bfs_orient(f: array)</a></li><li class="md-nav__item"><a href="#bone_parentsbe-array" title="bone_parents(be: array)" class="md-nav__link">bone_parents(be: array)</a></li><li class="md-nav__item"><a href="#boundary_facetst-array" title="boundary_facets(t: array)" class="md-nav__link">boundary_facets(t: array)</a></li><li class="md-nav__item"><a href="#boundary_loopf-array" title="boundary_loop(f: array)" class="md-nav__link">boundary_loop(f: array)</a></li><li class="md-nav__item"><a href="#bounding_boxargs-kwargs" title="bounding_box(*args, **kwargs)" class="md-nav__link">bounding_box(*args, **kwargs)</a></li><li class="md-nav__item"><a href="#bounding_boxv-array" title="bounding_box(v: array)" class="md-nav__link">bounding_box(v: array)</a></li><li class="md-nav__item"><a href="#bounding_boxv-array-pad-float" title="bounding_box(v: array, pad: float)" class="md-nav__link">bounding_box(v: array, pad: float)</a></li><li class="md-nav__item"><a href="#bounding_box_diagonalv-array-float" title="bounding_box_diagonal(v: array) -&gt; float" class="md-nav__link">bounding_box_diagonal(v: array) -&gt; float</a></li><li class="md-nav__item"><a href="#circumradiusv-array-f-array" title="circumradius(v: array, f: array)" class="md-nav__link">circumradius(v: array, f: array)</a></li><li class="md-nav__item"><a href="#collapse_small_trianglesv-array-f-array-eps-float" title="collapse_small_triangles(v: array, f: array, eps: float)" class="md-nav__link">collapse_small_triangles(v: array, f: array, eps: float)</a></li><li class="md-nav__item"><a href="#connect_boundary_to_infinityf-array" title="connect_boundary_to_infinity(f: array)" class="md-nav__link">connect_boundary_to_infinity(f: array)</a></li><li class="md-nav__item"><a href="#connect_boundary_to_infinity_facev-array-f-array" title="connect_boundary_to_infinity_face(v: array, f: array)" class="md-nav__link">connect_boundary_to_infinity_face(v: array, f: array)</a></li><li class="md-nav__item"><a href="#connect_boundary_to_infinity_indexf-array-inf_index-int" title="connect_boundary_to_infinity_index(f: array, inf_index: int)" class="md-nav__link">connect_boundary_to_infinity_index(f: array, inf_index: int)</a></li><li class="md-nav__item"><a href="#cotmatrixv-array-f-array" title="cotmatrix(v: array, f: array)" class="md-nav__link">cotmatrix(v: array, f: array)</a></li><li class="md-nav__item"><a href="#cotmatrix_entriesv-array-f-array" title="cotmatrix_entries(v: array, f: array)" class="md-nav__link">cotmatrix_entries(v: array, f: array)</a></li><li class="md-nav__item"><a href="#crouzeix_raviart_cotmatrixv-array-f-array" title="crouzeix_raviart_cotmatrix(v: array, f: array)" class="md-nav__link">crouzeix_raviart_cotmatrix(v: array, f: array)</a></li><li class="md-nav__item"><a href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array" title="crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array)" class="md-nav__link">crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array)</a></li><li class="md-nav__item"><a href="#crouzeix_raviart_massmatrixv-array-f-array" title="crouzeix_raviart_massmatrix(v: array, f: array)" class="md-nav__link">crouzeix_raviart_massmatrix(v: array, f: array)</a></li><li class="md-nav__item"><a href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array" title="crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array)" class="md-nav__link">crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array)</a></li><li class="md-nav__item"><a href="#cylinderaxis_devisions-int-height_devisions-int" title="cylinder(axis_devisions: int, height_devisions: int)" class="md-nav__link">cylinder(axis_devisions: int, height_devisions: int)</a></li><li class="md-nav__item"><a href="#decimatev-array-f-array-max_m-int" title="decimate(v: array, f: array, max_m: int)" class="md-nav__link">decimate(v: array, f: array, max_m: int)</a></li><li class="md-nav__item"><a href="#dihedral_anglesv-array-t-array" title="dihedral_angles(v: array, t: array)" class="md-nav__link">dihedral_angles(v: array, t: array)</a></li><li class="md-nav__item"><a href="#dihedral_angles_intrinsicl-array-a-array" title="dihedral_angles_intrinsic(l: array, a: array)" class="md-nav__link">dihedral_angles_intrinsic(l: array, a: array)</a></li><li class="md-nav__item"><a href="#directed_edge_parentse-array" title="directed_edge_parents(e: array)" class="md-nav__link">directed_edge_parents(e: array)</a></li><li class="md-nav__item"><a href="#doubleareav-array-f-array" title="doublearea(v: array, f: array)" class="md-nav__link">doublearea(v: array, f: array)</a></li><li class="md-nav__item"><a href="#earsf-array" title="ears(f: array)" class="md-nav__link">ears(f: array)</a></li><li class="md-nav__item"><a href="#edge_topologyv-array-f-array" title="edge_topology(v: array, f: array)" class="md-nav__link">edge_topology(v: array, f: array)</a></li><li class="md-nav__item"><a href="#edgesf-array" title="edges(f: array)" class="md-nav__link">edges(f: array)</a></li><li class="md-nav__item"><a href="#euler_characteristicf-array-int" title="euler_characteristic(f: array) -&gt; int" class="md-nav__link">euler_characteristic(f: array) -&gt; int</a></li><li class="md-nav__item"><a href="#euler_characteristic_completev-array-f-array-int" title="euler_characteristic_complete(v: array, f: array) -&gt; int" class="md-nav__link">euler_characteristic_complete(v: array, f: array) -&gt; int</a></li><li class="md-nav__item"><a href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none" title="exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None)" class="md-nav__link">exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None)</a></li><li class="md-nav__item"><a href="#face_componentsf-array" title="face_components(f: array)" class="md-nav__link">face_components(f: array)</a></li><li class="md-nav__item"><a href="#fit_planev-array" title="fit_plane(v: array)" class="md-nav__link">fit_plane(v: array)</a></li><li class="md-nav__item"><a href="#gaussian_curvaturev-array-f-array" title="gaussian_curvature(v: array, f: array)" class="md-nav__link">gaussian_curvature(v: array, f: array)</a></li><li class="md-nav__item"><a href="#gradv-array-f-array-uniform-bool-false" title="grad(v: array, f: array, uniform: bool = False)" class="md-nav__link">grad(v: array, f: array, uniform: bool = False)</a></li><li class="md-nav__item"><a href="#harmonic_integrated_with_laplacianl-sparse_matrix-m-sparse_matrix-k-int" title="harmonic_integrated_with_laplacian(l: sparse_matrix, m: sparse_matrix, k: int)" class="md-nav__link">harmonic_integrated_with_laplacian(l: sparse_matrix, m: sparse_matrix, k: int)</a></li><li class="md-nav__item"><a href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int" title="harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int)" class="md-nav__link">harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int)</a></li><li class="md-nav__item"><a href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int" title="harmonic_weights(v: array, f: array, b: array, bc: array, k: int)" class="md-nav__link">harmonic_weights(v: array, f: array, b: array, bc: array, k: int)</a></li><li class="md-nav__item"><a href="#internal_anglesv-array-f-array" title="internal_angles(v: array, f: array)" class="md-nav__link">internal_angles(v: array, f: array)</a></li><li class="md-nav__item"><a href="#is_edge_manifoldf-array-bool" title="is_edge_manifold(f: array) -&gt; bool" class="md-nav__link">is_edge_manifold(f: array) -&gt; bool</a></li><li class="md-nav__item"><a href="#is_irregular_vertexv-array-f-array-listbool" title="is_irregular_vertex(v: array, f: array) -&gt; List[bool]" class="md-nav__link">is_irregular_vertex(v: array, f: array) -&gt; List[bool]</a></li><li class="md-nav__item"><a href="#isolinesv-array-f-array-z-array-n-int" title="isolines(v: array, f: array, z: array, n: int)" class="md-nav__link">isolines(v: array, f: array, z: array, n: int)</a></li><li class="md-nav__item"><a href="#massmatrixv-array-f-array-type-int-1" title="massmatrix(v: array, f: array, type: int = 1)" class="md-nav__link">massmatrix(v: array, f: array, type: int = 1)</a></li><li class="md-nav__item"><a href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool" title="min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool)" class="md-nav__link">min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool)</a></li><li class="md-nav__item"><a href="#orientable_patchesf-array" title="orientable_patches(f: array)" class="md-nav__link">orientable_patches(f: array)</a></li><li class="md-nav__item"><a href="#oriented_facetsf-array" title="oriented_facets(f: array)" class="md-nav__link">oriented_facets(f: array)</a></li><li class="md-nav__item"><a href="#per_edge_normalsv-array-f-array-weight-int-0-fn-array" title="per_edge_normals(v: array, f: array, weight: int = 0, fn: array)" class="md-nav__link">per_edge_normals(v: array, f: array, weight: int = 0, fn: array)</a></li><li class="md-nav__item"><a href="#per_face_normalsv-array-f-array-z-array" title="per_face_normals(v: array, f: array, z: array)" class="md-nav__link">per_face_normals(v: array, f: array, z: array)</a></li><li class="md-nav__item"><a href="#per_face_normalsvfvector3d111normalizedn" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);</a></li><li class="md-nav__item"><a href="#per_vertex_attribute_smoothingain-array-f-array" title="per_vertex_attribute_smoothing(ain: array, f: array)" class="md-nav__link">per_vertex_attribute_smoothing(ain: array, f: array)</a></li><li class="md-nav__item"><a href="#per_vertex_normalsv-array-f-array-weighting-int-0" title="per_vertex_normals(v: array, f: array, weighting: int = 0)" class="md-nav__link">per_vertex_normals(v: array, f: array, weighting: int = 0)</a></li><li class="md-nav__item"><a href="#piecewise_constant_winding_numberf-array-bool" title="piecewise_constant_winding_number(f: array) -&gt; bool" class="md-nav__link">piecewise_constant_winding_number(f: array) -&gt; bool</a></li><li class="md-nav__item"><a href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true" title="principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True)" class="md-nav__link">principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True)</a></li><li class="md-nav__item"><a href="#procrustesx-array-y-array-include_scaling-bool-include_reflections-bool" title="procrustes(x: array, y: array, include_scaling: bool, include_reflections: bool)" class="md-nav__link">procrustes(x: array, y: array, include_scaling: bool, include_reflections: bool)</a></li><li class="md-nav__item"><a href="#qslimv-array-f-array-max_m-int" title="qslim(v: array, f: array, max_m: int)" class="md-nav__link">qslim(v: array, f: array, max_m: int)</a></li><li class="md-nav__item"><a href="#quad_planarityv-array-f-array" title="quad_planarity(v: array, f: array)" class="md-nav__link">quad_planarity(v: array, f: array)</a></li><li class="md-nav__item"><a href="#random_points_on_meshn-int-v-array-f-array" title="random_points_on_mesh(n: int, v: array, f: array)" class="md-nav__link">random_points_on_mesh(n: int, v: array, f: array)</a></li><li class="md-nav__item"><a href="#read_dmatfilename-str-dtype-dtype-float64" title="read_dmat(filename: str, dtype: dtype = &#39;float64&#39;)" class="md-nav__link">read_dmat(filename: str, dtype: dtype = &#39;float64&#39;)</a></li><li class="md-nav__item"><a href="#read_objfilename-str-dtype-dtype-float64" title="read_obj(filename: str, dtype: dtype = &#39;float64&#39;)" class="md-nav__link">read_obj(filename: str, dtype: dtype = &#39;float64&#39;)</a></li><li class="md-nav__item"><a href="#read_offfilename-str-read_normals-bool-true-dtype-dtype-float64" title="read_off(filename: str, read_normals: bool = True, dtype: dtype = &#39;float64&#39;)" class="md-nav__link">read_off(filename: str, read_normals: bool = True, dtype: dtype = &#39;float64&#39;)</a></li><li class="md-nav__item"><a href="#read_triangle_meshfilename-str-dtype-dtype-float64" title="read_triangle_mesh(filename: str, dtype: dtype = &#39;float64&#39;)" class="md-nav__link">read_triangle_mesh(filename: str, dtype: dtype = &#39;float64&#39;)</a></li><li class="md-nav__item"><a href="#remove_duplicate_verticesv-array-f-array-epsilon-float" title="remove_duplicate_vertices(v: array, f: array, epsilon: float)" class="md-nav__link">remove_duplicate_vertices(v: array, f: array, epsilon: float)</a></li><li class="md-nav__item"><a href="#remove_duplicatesv-array-f-array-epsilon-float" title="remove_duplicates(v: array, f: array, epsilon: float)" class="md-nav__link">remove_duplicates(v: array, f: array, epsilon: float)</a></li><li class="md-nav__item"><a href="#remove_unreferencedv-array-f-array" title="remove_unreferenced(v: array, f: array)" class="md-nav__link">remove_unreferenced(v: array, f: array)</a></li><li class="md-nav__item"><a href="#resolve_duplicated_facesf1-array" title="resolve_duplicated_faces(f1: array)" class="md-nav__link">resolve_duplicated_faces(f1: array)</a></li><li class="md-nav__item"><a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of" title="If the number of positively oriented faces equals the number of" class="md-nav__link">If the number of positively oriented faces equals the number of</a></li><li class="md-nav__item"><a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_1" title="If the number of positively oriented faces equals the number of" class="md-nav__link">If the number of positively oriented faces equals the number of</a></li><li class="md-nav__item"><a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_2" title="If the number of positively oriented faces equals the number of" class="md-nav__link">If the number of positively oriented faces equals the number of</a></li><li class="md-nav__item"><a href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of" title="If the number of postively oriented faces differ with the number of" class="md-nav__link">If the number of postively oriented faces differ with the number of</a></li><li class="md-nav__item"><a href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int" title="shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int)" class="md-nav__link">shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int)</a></li><li class="md-nav__item"><a href="#sort_anglesm-array" title="sort_angles(m: array)" class="md-nav__link">sort_angles(m: array)</a></li><li class="md-nav__item"><a href="#tet_tet_adjacencyt-array" title="tet_tet_adjacency(t: array)" class="md-nav__link">tet_tet_adjacency(t: array)</a></li><li class="md-nav__item"><a href="#tetrahedralizev-array-f-array-switches-str-pyq" title="tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;)" class="md-nav__link">tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;)</a></li><li class="md-nav__item"><a href="#triangle_triangle_adjacencyf-array" title="triangle_triangle_adjacency(f: array)" class="md-nav__link">triangle_triangle_adjacency(f: array)</a></li><li class="md-nav__item"><a href="#triangulatev-array-e-array-h-array-flags-str-a0005qq" title="triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;)" class="md-nav__link">triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;)</a></li><li class="md-nav__item"><a href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float" title="uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float)" class="md-nav__link">uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float)</a></li><li class="md-nav__item"><a href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float" title="uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float)" class="md-nav__link">uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float)</a></li><li class="md-nav__item"><a href="#unprojectwin-array-model-array-proj-array-viewport-array" title="unproject(win: array, model: array, proj: array, viewport: array)" class="md-nav__link">unproject(win: array, model: array, proj: array, viewport: array)</a></li><li class="md-nav__item"><a href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array" title="unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array)" class="md-nav__link">unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array)</a></li><li class="md-nav__item"><a href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array" title="unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array)" class="md-nav__link">unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array)</a></li><li class="md-nav__item"><a href="#unproject_raypos-array-model-array-proj-array-viewport-array" title="unproject_ray(pos: array, model: array, proj: array, viewport: array)" class="md-nav__link">unproject_ray(pos: array, model: array, proj: array, viewport: array)</a></li><li class="md-nav__item"><a href="#upsamplev-array-f-array-number_of_subdivs-int-1" title="upsample(v: array, f: array, number_of_subdivs: int = 1)" class="md-nav__link">upsample(v: array, f: array, number_of_subdivs: int = 1)</a></li><li class="md-nav__item"><a href="#vector_area_matrixf-array" title="vector_area_matrix(f: array)" class="md-nav__link">vector_area_matrix(f: array)</a></li><li class="md-nav__item"><a href="#vertex_componentsf-array" title="vertex_components(f: array)" class="md-nav__link">vertex_components(f: array)</a></li><li class="md-nav__item"><a href="#vertex_components_from_adjacency_matrixa-sparse_matrix" title="vertex_components_from_adjacency_matrix(a: sparse_matrix)" class="md-nav__link">vertex_components_from_adjacency_matrix(a: sparse_matrix)</a></li><li class="md-nav__item"><a href="#vertex_triangle_adjacencyf-array-n-int" title="vertex_triangle_adjacency(f: array, n: int)" class="md-nav__link">vertex_triangle_adjacency(f: array, n: int)</a></li><li class="md-nav__item"><a href="#winding_numberv-array-f-array-o-array" title="winding_number(v: array, f: array, o: array)" class="md-nav__link">winding_number(v: array, f: array, o: array)</a></li><li class="md-nav__item"><a href="#winding_number_for_pointv-array-f-array-p-array-float" title="winding_number_for_point(v: array, f: array, p: array) -&gt; float" class="md-nav__link">winding_number_for_point(v: array, f: array, p: array) -&gt; float</a></li><li class="md-nav__item"><a href="#write_objfilename-str-v-array-f-array-bool" title="write_obj(filename: str, v: array, f: array) -&gt; bool" class="md-nav__link">write_obj(filename: str, v: array, f: array) -&gt; bool</a></li><li class="md-nav__item"><a href="#write_offstr-str-v-array-f-array-c-array-bool" title="write_off(str: str, v: array, f: array, c: array) -&gt; bool" class="md-nav__link">write_off(str: str, v: array, f: array, c: array) -&gt; bool</a></li><li class="md-nav__item"><a href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool" title="write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool" class="md-nav__link">write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool</a></li></ul></nav></li><li class="md-nav__item"><a href="#class-arap" title="class ARAP" class="md-nav__link">class ARAP</a></li><li class="md-nav__item"><a href="#class-bbw" title="class BBW" class="md-nav__link">class BBW</a></li><li class="md-nav__item"><a href="#class-slim" title="class SLIM" class="md-nav__link">class SLIM</a></li></ul></nav></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component="toc"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--secondary"><label class="md-nav__title" for="__toc">Table of contents</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="#functions" title="Functions" class="md-nav__link">Functions</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#adjacency_listf-array" title="adjacency_list(f: array)" class="md-nav__link">adjacency_list(f: array)</a></li><li class="md-nav__item"><a href="#adjacency_matrixf-array" title="adjacency_matrix(f: array)" class="md-nav__link">adjacency_matrix(f: array)</a></li><li class="md-nav__item"><a href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int" title="ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int)" class="md-nav__link">ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int)</a></li><li class="md-nav__item"><a href="#arap_linear_blockv-array-f-array-d-int-energy-int" title="arap_linear_block(v: array, f: array, d: int, energy: int)" class="md-nav__link">arap_linear_block(v: array, f: array, d: int, energy: int)</a></li><li class="md-nav__item"><a href="#arap_linear_block_elementsv-array-f-array-d-int" title="arap_linear_block_elements(v: array, f: array, d: int)" class="md-nav__link">arap_linear_block_elements(v: array, f: array, d: int)</a></li><li class="md-nav__item"><a href="#arap_linear_block_spokesv-array-f-array-d-int" title="arap_linear_block_spokes(v: array, f: array, d: int)" class="md-nav__link">arap_linear_block_spokes(v: array, f: array, d: int)</a></li><li class="md-nav__item"><a href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int" title="arap_linear_block_spokes_and_rims(v: array, f: array, d: int)" class="md-nav__link">arap_linear_block_spokes_and_rims(v: array, f: array, d: int)</a></li><li class="md-nav__item"><a href="#arap_rhsv-array-f-array-d-int-energy-int" title="arap_rhs(v: array, f: array, d: int, energy: int)" class="md-nav__link">arap_rhs(v: array, f: array, d: int, energy: int)</a></li><li class="md-nav__item"><a href="#average_onto_verticesv-array-f-array-s-array" title="average_onto_vertices(v: array, f: array, s: array)" class="md-nav__link">average_onto_vertices(v: array, f: array, s: array)</a></li><li class="md-nav__item"><a href="#avg_edge_lengthv-array-f-array-float" title="avg_edge_length(v: array, f: array) -&gt; float" class="md-nav__link">avg_edge_length(v: array, f: array) -&gt; float</a></li><li class="md-nav__item"><a href="#barycenterv-array-f-array" title="barycenter(v: array, f: array)" class="md-nav__link">barycenter(v: array, f: array)</a></li><li class="md-nav__item"><a href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array" title="barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array)" class="md-nav__link">barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array)</a></li><li class="md-nav__item"><a href="#barycentric_coordinates_trip-array-a-array-b-array-c-array" title="barycentric_coordinates_tri(p: array, a: array, b: array, c: array)" class="md-nav__link">barycentric_coordinates_tri(p: array, a: array, b: array, c: array)</a></li><li class="md-nav__item"><a href="#bfsa-sparse_matrix-s-int" title="bfs(A: sparse_matrix, s: int)" class="md-nav__link">bfs(A: sparse_matrix, s: int)</a></li><li class="md-nav__item"><a href="#bfs_orientf-array" title="bfs_orient(f: array)" class="md-nav__link">bfs_orient(f: array)</a></li><li class="md-nav__item"><a href="#bone_parentsbe-array" title="bone_parents(be: array)" class="md-nav__link">bone_parents(be: array)</a></li><li class="md-nav__item"><a href="#boundary_facetst-array" title="boundary_facets(t: array)" class="md-nav__link">boundary_facets(t: array)</a></li><li class="md-nav__item"><a href="#boundary_loopf-array" title="boundary_loop(f: array)" class="md-nav__link">boundary_loop(f: array)</a></li><li class="md-nav__item"><a href="#bounding_boxargs-kwargs" title="bounding_box(*args, **kwargs)" class="md-nav__link">bounding_box(*args, **kwargs)</a></li><li class="md-nav__item"><a href="#bounding_boxv-array" title="bounding_box(v: array)" class="md-nav__link">bounding_box(v: array)</a></li><li class="md-nav__item"><a href="#bounding_boxv-array-pad-float" title="bounding_box(v: array, pad: float)" class="md-nav__link">bounding_box(v: array, pad: float)</a></li><li class="md-nav__item"><a href="#bounding_box_diagonalv-array-float" title="bounding_box_diagonal(v: array) -&gt; float" class="md-nav__link">bounding_box_diagonal(v: array) -&gt; float</a></li><li class="md-nav__item"><a href="#circumradiusv-array-f-array" title="circumradius(v: array, f: array)" class="md-nav__link">circumradius(v: array, f: array)</a></li><li class="md-nav__item"><a href="#collapse_small_trianglesv-array-f-array-eps-float" title="collapse_small_triangles(v: array, f: array, eps: float)" class="md-nav__link">collapse_small_triangles(v: array, f: array, eps: float)</a></li><li class="md-nav__item"><a href="#connect_boundary_to_infinityf-array" title="connect_boundary_to_infinity(f: array)" class="md-nav__link">connect_boundary_to_infinity(f: array)</a></li><li class="md-nav__item"><a href="#connect_boundary_to_infinity_facev-array-f-array" title="connect_boundary_to_infinity_face(v: array, f: array)" class="md-nav__link">connect_boundary_to_infinity_face(v: array, f: array)</a></li><li class="md-nav__item"><a href="#connect_boundary_to_infinity_indexf-array-inf_index-int" title="connect_boundary_to_infinity_index(f: array, inf_index: int)" class="md-nav__link">connect_boundary_to_infinity_index(f: array, inf_index: int)</a></li><li class="md-nav__item"><a href="#cotmatrixv-array-f-array" title="cotmatrix(v: array, f: array)" class="md-nav__link">cotmatrix(v: array, f: array)</a></li><li class="md-nav__item"><a href="#cotmatrix_entriesv-array-f-array" title="cotmatrix_entries(v: array, f: array)" class="md-nav__link">cotmatrix_entries(v: array, f: array)</a></li><li class="md-nav__item"><a href="#crouzeix_raviart_cotmatrixv-array-f-array" title="crouzeix_raviart_cotmatrix(v: array, f: array)" class="md-nav__link">crouzeix_raviart_cotmatrix(v: array, f: array)</a></li><li class="md-nav__item"><a href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array" title="crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array)" class="md-nav__link">crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array)</a></li><li class="md-nav__item"><a href="#crouzeix_raviart_massmatrixv-array-f-array" title="crouzeix_raviart_massmatrix(v: array, f: array)" class="md-nav__link">crouzeix_raviart_massmatrix(v: array, f: array)</a></li><li class="md-nav__item"><a href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array" title="crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array)" class="md-nav__link">crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array)</a></li><li class="md-nav__item"><a href="#cylinderaxis_devisions-int-height_devisions-int" title="cylinder(axis_devisions: int, height_devisions: int)" class="md-nav__link">cylinder(axis_devisions: int, height_devisions: int)</a></li><li class="md-nav__item"><a href="#decimatev-array-f-array-max_m-int" title="decimate(v: array, f: array, max_m: int)" class="md-nav__link">decimate(v: array, f: array, max_m: int)</a></li><li class="md-nav__item"><a href="#dihedral_anglesv-array-t-array" title="dihedral_angles(v: array, t: array)" class="md-nav__link">dihedral_angles(v: array, t: array)</a></li><li class="md-nav__item"><a href="#dihedral_angles_intrinsicl-array-a-array" title="dihedral_angles_intrinsic(l: array, a: array)" class="md-nav__link">dihedral_angles_intrinsic(l: array, a: array)</a></li><li class="md-nav__item"><a href="#directed_edge_parentse-array" title="directed_edge_parents(e: array)" class="md-nav__link">directed_edge_parents(e: array)</a></li><li class="md-nav__item"><a href="#doubleareav-array-f-array" title="doublearea(v: array, f: array)" class="md-nav__link">doublearea(v: array, f: array)</a></li><li class="md-nav__item"><a href="#earsf-array" title="ears(f: array)" class="md-nav__link">ears(f: array)</a></li><li class="md-nav__item"><a href="#edge_topologyv-array-f-array" title="edge_topology(v: array, f: array)" class="md-nav__link">edge_topology(v: array, f: array)</a></li><li class="md-nav__item"><a href="#edgesf-array" title="edges(f: array)" class="md-nav__link">edges(f: array)</a></li><li class="md-nav__item"><a href="#euler_characteristicf-array-int" title="euler_characteristic(f: array) -&gt; int" class="md-nav__link">euler_characteristic(f: array) -&gt; int</a></li><li class="md-nav__item"><a href="#euler_characteristic_completev-array-f-array-int" title="euler_characteristic_complete(v: array, f: array) -&gt; int" class="md-nav__link">euler_characteristic_complete(v: array, f: array) -&gt; int</a></li><li class="md-nav__item"><a href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none" title="exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None)" class="md-nav__link">exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None)</a></li><li class="md-nav__item"><a href="#face_componentsf-array" title="face_components(f: array)" class="md-nav__link">face_components(f: array)</a></li><li class="md-nav__item"><a href="#fit_planev-array" title="fit_plane(v: array)" class="md-nav__link">fit_plane(v: array)</a></li><li class="md-nav__item"><a href="#gaussian_curvaturev-array-f-array" title="gaussian_curvature(v: array, f: array)" class="md-nav__link">gaussian_curvature(v: array, f: array)</a></li><li class="md-nav__item"><a href="#gradv-array-f-array-uniform-bool-false" title="grad(v: array, f: array, uniform: bool = False)" class="md-nav__link">grad(v: array, f: array, uniform: bool = False)</a></li><li class="md-nav__item"><a href="#harmonic_integrated_with_laplacianl-sparse_matrix-m-sparse_matrix-k-int" title="harmonic_integrated_with_laplacian(l: sparse_matrix, m: sparse_matrix, k: int)" class="md-nav__link">harmonic_integrated_with_laplacian(l: sparse_matrix, m: sparse_matrix, k: int)</a></li><li class="md-nav__item"><a href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int" title="harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int)" class="md-nav__link">harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int)</a></li><li class="md-nav__item"><a href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int" title="harmonic_weights(v: array, f: array, b: array, bc: array, k: int)" class="md-nav__link">harmonic_weights(v: array, f: array, b: array, bc: array, k: int)</a></li><li class="md-nav__item"><a href="#internal_anglesv-array-f-array" title="internal_angles(v: array, f: array)" class="md-nav__link">internal_angles(v: array, f: array)</a></li><li class="md-nav__item"><a href="#is_edge_manifoldf-array-bool" title="is_edge_manifold(f: array) -&gt; bool" class="md-nav__link">is_edge_manifold(f: array) -&gt; bool</a></li><li class="md-nav__item"><a href="#is_irregular_vertexv-array-f-array-listbool" title="is_irregular_vertex(v: array, f: array) -&gt; List[bool]" class="md-nav__link">is_irregular_vertex(v: array, f: array) -&gt; List[bool]</a></li><li class="md-nav__item"><a href="#isolinesv-array-f-array-z-array-n-int" title="isolines(v: array, f: array, z: array, n: int)" class="md-nav__link">isolines(v: array, f: array, z: array, n: int)</a></li><li class="md-nav__item"><a href="#massmatrixv-array-f-array-type-int-1" title="massmatrix(v: array, f: array, type: int = 1)" class="md-nav__link">massmatrix(v: array, f: array, type: int = 1)</a></li><li class="md-nav__item"><a href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool" title="min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool)" class="md-nav__link">min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool)</a></li><li class="md-nav__item"><a href="#orientable_patchesf-array" title="orientable_patches(f: array)" class="md-nav__link">orientable_patches(f: array)</a></li><li class="md-nav__item"><a href="#oriented_facetsf-array" title="oriented_facets(f: array)" class="md-nav__link">oriented_facets(f: array)</a></li><li class="md-nav__item"><a href="#per_edge_normalsv-array-f-array-weight-int-0-fn-array" title="per_edge_normals(v: array, f: array, weight: int = 0, fn: array)" class="md-nav__link">per_edge_normals(v: array, f: array, weight: int = 0, fn: array)</a></li><li class="md-nav__item"><a href="#per_face_normalsv-array-f-array-z-array" title="per_face_normals(v: array, f: array, z: array)" class="md-nav__link">per_face_normals(v: array, f: array, z: array)</a></li><li class="md-nav__item"><a href="#per_face_normalsvfvector3d111normalizedn" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);</a></li><li class="md-nav__item"><a href="#per_vertex_attribute_smoothingain-array-f-array" title="per_vertex_attribute_smoothing(ain: array, f: array)" class="md-nav__link">per_vertex_attribute_smoothing(ain: array, f: array)</a></li><li class="md-nav__item"><a href="#per_vertex_normalsv-array-f-array-weighting-int-0" title="per_vertex_normals(v: array, f: array, weighting: int = 0)" class="md-nav__link">per_vertex_normals(v: array, f: array, weighting: int = 0)</a></li><li class="md-nav__item"><a href="#piecewise_constant_winding_numberf-array-bool" title="piecewise_constant_winding_number(f: array) -&gt; bool" class="md-nav__link">piecewise_constant_winding_number(f: array) -&gt; bool</a></li><li class="md-nav__item"><a href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true" title="principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True)" class="md-nav__link">principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True)</a></li><li class="md-nav__item"><a href="#procrustesx-array-y-array-include_scaling-bool-include_reflections-bool" title="procrustes(x: array, y: array, include_scaling: bool, include_reflections: bool)" class="md-nav__link">procrustes(x: array, y: array, include_scaling: bool, include_reflections: bool)</a></li><li class="md-nav__item"><a href="#qslimv-array-f-array-max_m-int" title="qslim(v: array, f: array, max_m: int)" class="md-nav__link">qslim(v: array, f: array, max_m: int)</a></li><li class="md-nav__item"><a href="#quad_planarityv-array-f-array" title="quad_planarity(v: array, f: array)" class="md-nav__link">quad_planarity(v: array, f: array)</a></li><li class="md-nav__item"><a href="#random_points_on_meshn-int-v-array-f-array" title="random_points_on_mesh(n: int, v: array, f: array)" class="md-nav__link">random_points_on_mesh(n: int, v: array, f: array)</a></li><li class="md-nav__item"><a href="#read_dmatfilename-str-dtype-dtype-float64" title="read_dmat(filename: str, dtype: dtype = &#39;float64&#39;)" class="md-nav__link">read_dmat(filename: str, dtype: dtype = &#39;float64&#39;)</a></li><li class="md-nav__item"><a href="#read_objfilename-str-dtype-dtype-float64" title="read_obj(filename: str, dtype: dtype = &#39;float64&#39;)" class="md-nav__link">read_obj(filename: str, dtype: dtype = &#39;float64&#39;)</a></li><li class="md-nav__item"><a href="#read_offfilename-str-read_normals-bool-true-dtype-dtype-float64" title="read_off(filename: str, read_normals: bool = True, dtype: dtype = &#39;float64&#39;)" class="md-nav__link">read_off(filename: str, read_normals: bool = True, dtype: dtype = &#39;float64&#39;)</a></li><li class="md-nav__item"><a href="#read_triangle_meshfilename-str-dtype-dtype-float64" title="read_triangle_mesh(filename: str, dtype: dtype = &#39;float64&#39;)" class="md-nav__link">read_triangle_mesh(filename: str, dtype: dtype = &#39;float64&#39;)</a></li><li class="md-nav__item"><a href="#remove_duplicate_verticesv-array-f-array-epsilon-float" title="remove_duplicate_vertices(v: array, f: array, epsilon: float)" class="md-nav__link">remove_duplicate_vertices(v: array, f: array, epsilon: float)</a></li><li class="md-nav__item"><a href="#remove_duplicatesv-array-f-array-epsilon-float" title="remove_duplicates(v: array, f: array, epsilon: float)" class="md-nav__link">remove_duplicates(v: array, f: array, epsilon: float)</a></li><li class="md-nav__item"><a href="#remove_unreferencedv-array-f-array" title="remove_unreferenced(v: array, f: array)" class="md-nav__link">remove_unreferenced(v: array, f: array)</a></li><li class="md-nav__item"><a href="#resolve_duplicated_facesf1-array" title="resolve_duplicated_faces(f1: array)" class="md-nav__link">resolve_duplicated_faces(f1: array)</a></li><li class="md-nav__item"><a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of" title="If the number of positively oriented faces equals the number of" class="md-nav__link">If the number of positively oriented faces equals the number of</a></li><li class="md-nav__item"><a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_1" title="If the number of positively oriented faces equals the number of" class="md-nav__link">If the number of positively oriented faces equals the number of</a></li><li class="md-nav__item"><a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_2" title="If the number of positively oriented faces equals the number of" class="md-nav__link">If the number of positively oriented faces equals the number of</a></li><li class="md-nav__item"><a href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of" title="If the number of postively oriented faces differ with the number of" class="md-nav__link">If the number of postively oriented faces differ with the number of</a></li><li class="md-nav__item"><a href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int" title="shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int)" class="md-nav__link">shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int)</a></li><li class="md-nav__item"><a href="#sort_anglesm-array" title="sort_angles(m: array)" class="md-nav__link">sort_angles(m: array)</a></li><li class="md-nav__item"><a href="#tet_tet_adjacencyt-array" title="tet_tet_adjacency(t: array)" class="md-nav__link">tet_tet_adjacency(t: array)</a></li><li class="md-nav__item"><a href="#tetrahedralizev-array-f-array-switches-str-pyq" title="tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;)" class="md-nav__link">tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;)</a></li><li class="md-nav__item"><a href="#triangle_triangle_adjacencyf-array" title="triangle_triangle_adjacency(f: array)" class="md-nav__link">triangle_triangle_adjacency(f: array)</a></li><li class="md-nav__item"><a href="#triangulatev-array-e-array-h-array-flags-str-a0005qq" title="triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;)" class="md-nav__link">triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;)</a></li><li class="md-nav__item"><a href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float" title="uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float)" class="md-nav__link">uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float)</a></li><li class="md-nav__item"><a href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float" title="uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float)" class="md-nav__link">uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float)</a></li><li class="md-nav__item"><a href="#unprojectwin-array-model-array-proj-array-viewport-array" title="unproject(win: array, model: array, proj: array, viewport: array)" class="md-nav__link">unproject(win: array, model: array, proj: array, viewport: array)</a></li><li class="md-nav__item"><a href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array" title="unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array)" class="md-nav__link">unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array)</a></li><li class="md-nav__item"><a href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array" title="unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array)" class="md-nav__link">unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array)</a></li><li class="md-nav__item"><a href="#unproject_raypos-array-model-array-proj-array-viewport-array" title="unproject_ray(pos: array, model: array, proj: array, viewport: array)" class="md-nav__link">unproject_ray(pos: array, model: array, proj: array, viewport: array)</a></li><li class="md-nav__item"><a href="#upsamplev-array-f-array-number_of_subdivs-int-1" title="upsample(v: array, f: array, number_of_subdivs: int = 1)" class="md-nav__link">upsample(v: array, f: array, number_of_subdivs: int = 1)</a></li><li class="md-nav__item"><a href="#vector_area_matrixf-array" title="vector_area_matrix(f: array)" class="md-nav__link">vector_area_matrix(f: array)</a></li><li class="md-nav__item"><a href="#vertex_componentsf-array" title="vertex_components(f: array)" class="md-nav__link">vertex_components(f: array)</a></li><li class="md-nav__item"><a href="#vertex_components_from_adjacency_matrixa-sparse_matrix" title="vertex_components_from_adjacency_matrix(a: sparse_matrix)" class="md-nav__link">vertex_components_from_adjacency_matrix(a: sparse_matrix)</a></li><li class="md-nav__item"><a href="#vertex_triangle_adjacencyf-array-n-int" title="vertex_triangle_adjacency(f: array, n: int)" class="md-nav__link">vertex_triangle_adjacency(f: array, n: int)</a></li><li class="md-nav__item"><a href="#winding_numberv-array-f-array-o-array" title="winding_number(v: array, f: array, o: array)" class="md-nav__link">winding_number(v: array, f: array, o: array)</a></li><li class="md-nav__item"><a href="#winding_number_for_pointv-array-f-array-p-array-float" title="winding_number_for_point(v: array, f: array, p: array) -&gt; float" class="md-nav__link">winding_number_for_point(v: array, f: array, p: array) -&gt; float</a></li><li class="md-nav__item"><a href="#write_objfilename-str-v-array-f-array-bool" title="write_obj(filename: str, v: array, f: array) -&gt; bool" class="md-nav__link">write_obj(filename: str, v: array, f: array) -&gt; bool</a></li><li class="md-nav__item"><a href="#write_offstr-str-v-array-f-array-c-array-bool" title="write_off(str: str, v: array, f: array, c: array) -&gt; bool" class="md-nav__link">write_off(str: str, v: array, f: array, c: array) -&gt; bool</a></li><li class="md-nav__item"><a href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool" title="write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool" class="md-nav__link">write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool</a></li></ul></nav></li><li class="md-nav__item"><a href="#class-arap" title="class ARAP" class="md-nav__link">class ARAP</a></li><li class="md-nav__item"><a href="#class-bbw" title="class BBW" class="md-nav__link">class BBW</a></li><li class="md-nav__item"><a href="#class-slim" title="class SLIM" class="md-nav__link">class SLIM</a></li></ul></nav></div></div></div><div class="md-content"><article class="md-content__inner md-typeset"><a href="https://github.com/geometryprocessing/libigl-python-bindings/edit/master/docs/igl_docs.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a><h1>Docs</h1><h2 id="functions">Functions<a class="headerlink" href="#functions" title="Permanent link">&para;</a></h2>
<h3 id="adjacency_listf-array"><strong><code class="codehilite"><span class="n">adjacency_list</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#adjacency_listf-array" title="Permanent link">&para;</a></h3>
<p>Constructs the graph adjacency list of a given mesh (v, f)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3),</br>tet (#f by 4), quad (#f by 4), etc&hellip;) mesh faces</td>
</tr>
<tr>
<td>Returns</td>
<td>list of lists containing at index i the adjacent vertices of vertex i</td>
</tr>
<tr>
<td>See also</td>
<td>adjacency_matrix</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">a</span> <span class="o">=</span> <span class="n">mesh_adjacency_list</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">adjacency_matrix</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="adjacency_matrixf-array"><strong><code class="codehilite"><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#adjacency_matrixf-array" title="Permanent link">&para;</a></h3>
<p>Constructs the graph adjacency matrix of a given mesh (v, f).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : #f by dim list of mesh simplices</td>
</tr>
<tr>
<td>Returns</td>
<td>a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :)</td>
</tr>
<tr>
<td>See also</td>
<td>adjacency_list, edges, cotmatrix, diag</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">a</span> <span class="o">=</span> <span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1"># Sum each row</span>
 <span class="n">a_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Convert row sums into diagonal of sparse matrix</span>
 <span class="n">a_diag</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">a_sum</span><span class="p">)</span>
<span class="c1"># Build uniform laplacian</span>
 <span class="n">u</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">a_diag</span>
<span class="n">igl</span><span class="o">.</span><span class="n">ambient_occlusion</span> <span class="o">=</span> <span class="n">ambient_occlusion</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int"><strong><code class="codehilite"><span class="n">ambient_occlusion</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by 3 list of mesh vertex positions</br>F  #F by 3 list of mesh face indices into V</br>P  #P by 3 list of origin points</br>N  #P by 3 list of origin normals</td>
</tr>
<tr>
<td>Returns</td>
<td>S  #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded)</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">arap_linear_block</span> <span class="o">=</span> <span class="n">arap_linear_block</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="arap_linear_blockv-array-f-array-d-int-energy-int"><strong><code class="codehilite"><span class="n">arap_linear_block</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">energy</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#arap_linear_blockv-array-f-array-d-int-energy-int" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the
linear terms of a given arap energy. When treating rotations as knowns
(arranged in a column), then this constructs Kd of K such that the linear
portion of the energy is as a column:
K * R = [Kx Z  &hellip; Ky Z  &hellip;
Z  Kx &hellip; Z  Ky &hellip;
&hellip; ]
These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.
Here we want to build a scatter matrix that multiplies against positions
(treated as known) producing covariance matrices to fit each rotation.
Notice that in the case of the RHS of the poisson solve the rotations are
known and the positions unknown, and vice versa for rotation fitting.
These linear block just relate the rotations to the positions, linearly in
each.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim list of initial domain positions</br>f : #f by #simplex size list of triangle indices into V</br>d : coordinate of linear constructor to build</td>
</tr>
<tr>
<td>Returns</td>
<td>#v by #v/#f block of the linear constructor matrix corresponding to coordinate d</td>
</tr>
<tr>
<td>See also</td>
<td>arap, arap_dof</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">arap_linear_block_elements</span> <span class="o">=</span> <span class="n">arap_linear_block_elements</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="arap_linear_block_elementsv-array-f-array-d-int"><strong><code class="codehilite"><span class="n">arap_linear_block_elements</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#arap_linear_block_elementsv-array-f-array-d-int" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the
linear terms of a given arap energy. When treating rotations as knowns
(arranged in a column), then this constructs Kd of K such that the linear
portion of the energy is as a column:
K * R = [Kx Z  &hellip; Ky Z  &hellip;
Z  Kx &hellip; Z  Ky &hellip;
&hellip; ]
These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.
Here we want to build a scatter matrix that multiplies against positions
(treated as known) producing covariance matrices to fit each rotation.
Notice that in the case of the RHS of the poisson solve the rotations are
known and the positions unknown, and vice versa for rotation fitting.
These linear block just relate the rotations to the positions, linearly in
each.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim list of initial domain positions</br>f : #f by #simplex size list of triangle indices into V</br>d : coordinate of linear constructor to build</td>
</tr>
<tr>
<td>Returns</td>
<td>#v by #v/#f block of the linear constructor matrix corresponding to coordinate d</td>
</tr>
<tr>
<td>See also</td>
<td>arap, arap_dof</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">arap_linear_block_spokes</span> <span class="o">=</span> <span class="n">arap_linear_block_spokes</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="arap_linear_block_spokesv-array-f-array-d-int"><strong><code class="codehilite"><span class="n">arap_linear_block_spokes</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#arap_linear_block_spokesv-array-f-array-d-int" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the
linear terms of a given arap energy. When treating rotations as knowns
(arranged in a column), then this constructs Kd of K such that the linear
portion of the energy is as a column:
K * R = [Kx Z  &hellip; Ky Z  &hellip;
Z  Kx &hellip; Z  Ky &hellip;
&hellip; ]
These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.
Here we want to build a scatter matrix that multiplies against positions
(treated as known) producing covariance matrices to fit each rotation.
Notice that in the case of the RHS of the poisson solve the rotations are
known and the positions unknown, and vice versa for rotation fitting.
These linear block just relate the rotations to the positions, linearly in
each.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim list of initial domain positions</br>f : #f by #simplex size list of triangle indices into V</br>d : coordinate of linear constructor to build</td>
</tr>
<tr>
<td>Returns</td>
<td>#v by #v/#f block of the linear constructor matrix corresponding to coordinate d</td>
</tr>
<tr>
<td>See also</td>
<td>arap, arap_dof</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">arap_linear_block_spokes_and_rims</span> <span class="o">=</span> <span class="n">arap_linear_block_spokes_and_rims</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="arap_linear_block_spokes_and_rimsv-array-f-array-d-int"><strong><code class="codehilite"><span class="n">arap_linear_block_spokes_and_rims</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the
linear terms of a given arap energy. When treating rotations as knowns
(arranged in a column), then this constructs Kd of K such that the linear
portion of the energy is as a column:
K * R = [Kx Z  &hellip; Ky Z  &hellip;
Z  Kx &hellip; Z  Ky &hellip;
&hellip; ]
These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.
Here we want to build a scatter matrix that multiplies against positions
(treated as known) producing covariance matrices to fit each rotation.
Notice that in the case of the RHS of the poisson solve the rotations are
known and the positions unknown, and vice versa for rotation fitting.
These linear block just relate the rotations to the positions, linearly in
each.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim list of initial domain positions</br>f : #f by #simplex size list of triangle indices into V</br>d : coordinate of linear constructor to build</td>
</tr>
<tr>
<td>Returns</td>
<td>#v by #v/#f block of the linear constructor matrix corresponding to coordinate d</td>
</tr>
<tr>
<td>See also</td>
<td>arap, arap_dof</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">arap_rhs</span> <span class="o">=</span> <span class="n">arap_rhs</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="arap_rhsv-array-f-array-d-int-energy-int"><strong><code class="codehilite"><span class="n">arap_rhs</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">energy</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#arap_rhsv-array-f-array-d-int-energy-int" title="Permanent link">&para;</a></h3>
<p>Guild right-hand side constructor of global poisson solve for various ARAP energies
Inputs:
Outputs:
K  #V*dim by #(FV)*dim*dim matrix such that:
b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1);</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by Vdim list of initial domain positions</br>f : #f by 3 list of triangle indices into v</br>d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2</br>energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations.</td>
</tr>
<tr>
<td>Returns</td>
<td>#v*d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1);</td>
</tr>
<tr>
<td>See also</td>
<td>arap_linear_block, arap</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">average_onto_vertices</span> <span class="o">=</span> <span class="n">average_onto_vertices</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="average_onto_verticesv-array-f-array-s-array"><strong><code class="codehilite"><span class="n">average_onto_vertices</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#average_onto_verticesv-array-f-array-s-array" title="Permanent link">&para;</a></h3>
<p>Move a scalar field defined on faces to vertices by averaging</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by vdim array of mesh vertices</br>f : #f by simplex_count array of simplex indices</br>s : #f by dim scalar field defined on simplices</td>
</tr>
<tr>
<td>Returns</td>
<td>#v by dim scalar field defined on vertices</td>
</tr>
<tr>
<td>See also</td>
<td>average_onto_faces</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">avg_edge_length</span> <span class="o">=</span> <span class="n">avg_edge_length</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="avg_edge_lengthv-array-f-array-float"><strong><code class="codehilite"><span class="n">avg_edge_length</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span></code></strong><a class="headerlink" href="#avg_edge_lengthv-array-f-array-float" title="Permanent link">&para;</a></h3>
<p>Compute the average edge length for the given triangle mesh.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : array_like #v by 3 vertex array</br>f : f #f by simplex-size list of mesh faces (must be simplex)</td>
</tr>
<tr>
<td>Returns</td>
<td>l : average edge length</td>
</tr>
<tr>
<td>See also</td>
<td>adjacency_matrix</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">length</span> <span class="o">=</span> <span class="n">avg_edge_length</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span> <span class="o">=</span> <span class="n">barycenter</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="barycenterv-array-f-array"><strong><code class="codehilite"><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#barycenterv-array-f-array" title="Permanent link">&para;</a></h3>
<p>Compute the barycenter of every simplex</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v x dim matrix of vertex coordinates</br>f : #f x simplex_size  matrix of indices of simplex corners into V</td>
</tr>
<tr>
<td>Returns</td>
<td>A #f x dim matrix where each row is the barycenter of each simplex</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">barycentric_coordinates_tet</span> <span class="o">=</span> <span class="n">barycentric_coordinates_tet</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array"><strong><code class="codehilite"><span class="n">barycentric_coordinates_tet</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="k">c</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array" title="Permanent link">&para;</a></h3>
<p>Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in <code class="codehilite"><span class="n">p</span></code>.
The input arrays <code class="codehilite"><span class="n">a</span></code>, <code class="codehilite"><span class="n">b</span></code>, <code class="codehilite"><span class="k">c</span></code> and <code class="codehilite"><span class="n">d</span></code> are the vertices of each tet. I.e. one tet is
<code class="codehilite"><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="k">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span></code>.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>p : #P by 3 Query points in 3d</br>a : #P by 3 Tet corners in 3d</br>b : #P by 3 Tet corners in 3d</br>c : #P by 3 Tet corners in 3d</br>d : #P by 3 Tet corners in 3d</td>
</tr>
<tr>
<td>Returns</td>
<td>#P by 4 list of barycentric coordinates</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">barycentric_coordinates_tri</span> <span class="o">=</span> <span class="n">barycentric_coordinates_tri</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="barycentric_coordinates_trip-array-a-array-b-array-c-array"><strong><code class="codehilite"><span class="n">barycentric_coordinates_tri</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="k">c</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#barycentric_coordinates_trip-array-a-array-b-array-c-array" title="Permanent link">&para;</a></h3>
<p>Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in <code class="codehilite"><span class="n">p</span></code>.
The input arrays <code class="codehilite"><span class="n">a</span></code>, <code class="codehilite"><span class="n">b</span></code>, and <code class="codehilite"><span class="k">c</span></code> are the vertices of each triangle. I.e. one triangle is
<code class="codehilite"><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="k">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span></code>.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>p : #P by 3 Query points in 3d</br>a : #P by 3 Tri corners in 3d</br>b : #P by 3 Tri corners in 3d</br>c : #P by 3 Tri corners in 3d</td>
</tr>
<tr>
<td>Returns</td>
<td>#P by 3 list of barycentric coordinates</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">bfs</span> <span class="o">=</span> <span class="n">bfs</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="bfsa-sparse_matrix-s-int"><strong><code class="codehilite"><span class="n">bfs</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">sparse_matrix</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#bfsa-sparse_matrix-s-int" title="Permanent link">&para;</a></h3>
<p>Construct an array indexing into a <strong>directed</strong> graph represented by an adjacency list using
breadth first search. I.e. the output is an array of vertices in breadth-first order.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>A : #V list of adjacency lists  or #V by #V adjacency matrix</br>s : starting node (index into A)</td>
</tr>
<tr>
<td>Returns</td>
<td>A tuple, (d, p) where:</br>* d is a #V list of indices into rows of A in the order in which graph nodes are discovered</br>* p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e.</br>p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal.</br>Note that together, (d, p) form a spanning tree of the input graph</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span> <span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">readOFF</span><span class="p">(</span><span class="s2">&quot;test.off)</span>
 <span class="n">A</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
 <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">igl</span><span class="o">.</span><span class="n">bfs_orient</span> <span class="o">=</span> <span class="n">bfs_orient</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="bfs_orientf-array"><strong><code class="codehilite"><span class="n">bfs_orient</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#bfs_orientf-array" title="Permanent link">&para;</a></h3>
<p>Consistently orient faces in orientable patches using BFS.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : #F by 3 list of faces</td>
</tr>
<tr>
<td>Returns</td>
<td>A tuple, (ff, c) where:</br>* ff is a #F by 3 list of faces which are consistently oriented with</br>* c is a #F array of connected component ids</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">readOFF</span><span class="p">(</span><span class="s2">&quot;test.off)</span>
 <span class="n">ff</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">bfs_orient</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">bone_parents</span> <span class="o">=</span> <span class="n">bone_parents</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="bone_parentsbe-array"><strong><code class="codehilite"><span class="n">bone_parents</span><span class="p">(</span><span class="n">be</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#bone_parentsbe-array" title="Permanent link">&para;</a></h3>
<p>BONE_PARENTS Recover &ldquo;parent&rdquo; bones from directed graph representation.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>BE  #BE by 2 list of directed bone edges</td>
</tr>
<tr>
<td>Returns</td>
<td>P  #BE by 1 list of parent indices into BE, -1 means root.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">boundary_facets</span> <span class="o">=</span> <span class="n">boundary_facets</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="boundary_facetst-array"><strong><code class="codehilite"><span class="n">boundary_facets</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#boundary_facetst-array" title="Permanent link">&para;</a></h3>
<p>Determine boundary faces (edges) of tetrahedra (triangles).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles</td>
</tr>
<tr>
<td>Returns</td>
<td>f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">b</span> <span class="o">=</span> <span class="n">boundary_facets</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">boundary_loop</span> <span class="o">=</span> <span class="n">boundary_loop</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="boundary_loopf-array"><strong><code class="codehilite"><span class="n">boundary_loop</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#boundary_loopf-array" title="Permanent link">&para;</a></h3>
<p>Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : #v by dim array of mesh faces</td>
</tr>
<tr>
<td>Returns</td>
<td>l : ordered list of boundary vertices of longest boundary loop</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">boundary_loop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="bounding_boxargs-kwargs"><strong><code class="codehilite"><span class="n">bounding_box</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></strong><a class="headerlink" href="#bounding_boxargs-kwargs" title="Permanent link">&para;</a></h3>
<h3 id="bounding_boxv-array"><strong><code class="codehilite"><span class="n">bounding_box</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#bounding_boxv-array" title="Permanent link">&para;</a></h3>
<p>Build a triangle mesh of the bounding box of a given list of vertices</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of rest domain positions</td>
</tr>
<tr>
<td>Returns</td>
<td>BV  2^dim by dim list of bounding box corners positions</br>BF  #BF by dim list of simplex facets</td>
</tr>
</tbody>
</table>
<h3 id="bounding_boxv-array-pad-float"><strong><code class="codehilite"><span class="n">bounding_box</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="k">pad</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span></code></strong><a class="headerlink" href="#bounding_boxv-array-pad-float" title="Permanent link">&para;</a></h3>
<p>Build a triangle mesh of the bounding box of a given list of vertices</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of rest domain positions</td>
</tr>
<tr>
<td>Returns</td>
<td>BV  2^dim by dim list of bounding box corners positions</br>BF  #BF by dim list of simplex facets</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">bounding_box_diagonal</span> <span class="o">=</span> <span class="n">bounding_box_diagonal</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="bounding_box_diagonalv-array-float"><strong><code class="codehilite"><span class="n">bounding_box_diagonal</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span></code></strong><a class="headerlink" href="#bounding_box_diagonalv-array-float" title="Permanent link">&para;</a></h3>
<p>Compute the length of the diagonal of a given meshes axis-aligned bounding</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by 3 list of vertex positions</td>
</tr>
<tr>
<td>Returns</td>
<td>Returns length of bounding box diagonal</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">circumradius</span> <span class="o">=</span> <span class="n">circumradius</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="circumradiusv-array-f-array"><strong><code class="codehilite"><span class="n">circumradius</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#circumradiusv-array-f-array" title="Permanent link">&para;</a></h3>
<p>Compute the circumradius of each triangle in a mesh (V,F)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of mesh vertex positions</br>F  #F by 3 list of triangle indices into V</td>
</tr>
<tr>
<td>Returns</td>
<td>R  #F list of circumradii</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">R</span> <span class="o">=</span> <span class="n">circumradius</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">collapse_small_triangles</span> <span class="o">=</span> <span class="n">collapse_small_triangles</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="collapse_small_trianglesv-array-f-array-eps-float"><strong><code class="codehilite"><span class="n">collapse_small_triangles</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span></code></strong><a class="headerlink" href="#collapse_small_trianglesv-array-f-array-eps-float" title="Permanent link">&para;</a></h3>
<p>Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the
original faces and vertices of (V,F) except any small triangles have been
removed via collapse.
We are <em>not</em> following the rules in &ldquo;Mesh Optimization&rdquo; [Hoppe et al]
Section 4.2. But for our purposes we don&rsquo;t care about this criteria.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by 3 list of vertex positions</br>F  #F by 3 list of triangle indices into V</br>eps  epsilon for smallest allowed area treated as fraction of squared bounding box</br>diagonal</td>
</tr>
<tr>
<td>Returns</td>
<td>FF  #FF by 3 list of triangle indices into V</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">connect_boundary_to_infinity</span> <span class="o">=</span> <span class="n">connect_boundary_to_infinity</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="connect_boundary_to_infinityf-array"><strong><code class="codehilite"><span class="n">connect_boundary_to_infinity</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#connect_boundary_to_infinityf-array" title="Permanent link">&para;</a></h3>
<p>Connect all boundary edges to a fictitious point at infinity.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>F  #F by 3 list of face indices into some V</td>
</tr>
<tr>
<td>Returns</td>
<td>FO  #F+#O by 3 list of face indices into [V;inf inf inf], original F are</br>guaranteed to come first. If (V,F) was a manifold mesh, now it is</br>closed with a possibly non-manifold vertex at infinity (but it will be</br>edge-manifold).</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">connect_boundary_to_infinity_face</span> <span class="o">=</span> <span class="n">connect_boundary_to_infinity_face</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="connect_boundary_to_infinity_facev-array-f-array"><strong><code class="codehilite"><span class="n">connect_boundary_to_infinity_face</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#connect_boundary_to_infinity_facev-array-f-array" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>F  #F by 3 list of face indices into some V</td>
</tr>
<tr>
<td>Returns</td>
<td>FO  #F+#O by 3 list of face indices into VO</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">connect_boundary_to_infinity_index</span> <span class="o">=</span> <span class="n">connect_boundary_to_infinity_index</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="connect_boundary_to_infinity_indexf-array-inf_index-int"><strong><code class="codehilite"><span class="n">connect_boundary_to_infinity_index</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">inf_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#connect_boundary_to_infinity_indexf-array-inf_index-int" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>inf_index  index of point at infinity (usually V.rows() or F.maxCoeff())</td>
</tr>
<tr>
<td>Returns</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span> <span class="o">=</span> <span class="n">cotmatrix</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="cotmatrixv-array-f-array"><strong><code class="codehilite"><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#cotmatrixv-array-f-array" title="Permanent link">&para;</a></h3>
<p>Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh
(v, f).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim list of mesh vertex positions</br>f : #f by simplex_size list of mesh faces (must be triangles)</td>
</tr>
<tr>
<td>Returns</td>
<td>l : #v by #v cotangent matrix, each row i corresponding to v(i, :)</td>
</tr>
<tr>
<td>See also</td>
<td>adjacency_matrix</td>
</tr>
<tr>
<td>Notes</td>
<td>This Laplacian uses the convention that diagonal entries are</br><strong>minus</strong> the sum of off-diagonal entries. The diagonal entries are</br>therefore in general negative and the matrix is <strong>negative</strong> semi-definite</br>(immediately, -L is <strong>positive</strong> semi-definite)</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">l</span> <span class="o">=</span> <span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix_entries</span> <span class="o">=</span> <span class="n">cotmatrix_entries</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="cotmatrix_entriesv-array-f-array"><strong><code class="codehilite"><span class="n">cotmatrix_entries</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#cotmatrix_entriesv-array-f-array" title="Permanent link">&para;</a></h3>
<p>COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of rest domain positions</br>F  #F by {34} list of {triangletetrahedra} indices into V</td>
</tr>
<tr>
<td>Returns</td>
<td>C  #F by 3 list of &frac12;*cotangents corresponding angles</br>for triangles, columns correspond to edges [1,2],[2,0],[0,1]</br>OR</br>C  #F by 6 list of &#8537;*cotangents of dihedral angles*edge lengths</br>for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2]</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">crouzeix_raviart_cotmatrix</span> <span class="o">=</span> <span class="n">crouzeix_raviart_cotmatrix</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="crouzeix_raviart_cotmatrixv-array-f-array"><strong><code class="codehilite"><span class="n">crouzeix_raviart_cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#crouzeix_raviart_cotmatrixv-array-f-array" title="Permanent link">&para;</a></h3>
<p>CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent
stiffness matrix.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of vertex positions</br>F  #F by 3 / 4 list of triangle/tetrahedron indices</td>
</tr>
<tr>
<td>Returns</td>
<td>L  #E by #E edge/face-based diagonal cotangent matrix</br>E  #E by 2 / 3 list of edges/faces</br>EMAP  #F*3 / 4 list of indices mapping allE to E</td>
</tr>
<tr>
<td>See also</td>
<td>See also: crouzeix_raviart_massmatrix</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">See</span> <span class="k">for</span> <span class="n">example</span> <span class="s2">&quot;Discrete Quadratic Curvature Energies&quot;</span> <span class="p">[</span><span class="n">Wardetzky</span><span class="p">,</span> <span class="n">Bergou</span><span class="p">,</span>
<span class="n">Harmon</span><span class="p">,</span> <span class="n">Zorin</span><span class="p">,</span> <span class="n">Grinspun</span> <span class="mi">2007</span><span class="p">]</span>
<span class="n">igl</span><span class="o">.</span><span class="n">crouzeix_raviart_cotmatrix_known_e</span> <span class="o">=</span> <span class="n">crouzeix_raviart_cotmatrix_known_e</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array"><strong><code class="codehilite"><span class="n">crouzeix_raviart_cotmatrix_known_e</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">emap</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array" title="Permanent link">&para;</a></h3>
<p>wrapper if E and EMAP are already computed (better match!)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td></td>
</tr>
<tr>
<td>Returns</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">crouzeix_raviart_massmatrix</span> <span class="o">=</span> <span class="n">crouzeix_raviart_massmatrix</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="crouzeix_raviart_massmatrixv-array-f-array"><strong><code class="codehilite"><span class="n">crouzeix_raviart_massmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#crouzeix_raviart_massmatrixv-array-f-array" title="Permanent link">&para;</a></h3>
<p>CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where
M(e,e) is just the sum of the areas of the triangles on either side of an
edge e.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of vertex positions</br>F  #F by 3 / 4 list of triangle/tetrahedron indices</td>
</tr>
<tr>
<td>Returns</td>
<td>M  #E by #E edge/face-based diagonal mass matrix</br>E  #E by 2 / 3 list of edges/faces</br>EMAP  #F*3 / 4 list of indices mapping allE to E</td>
</tr>
<tr>
<td>See also</td>
<td>crouzeix_raviart_cotmatrix</td>
</tr>
<tr>
<td>Notes</td>
<td>See for example &ldquo;Discrete Quadratic Curvature Energies&rdquo; [Wardetzky, Bergou,</br>Harmon, Zorin, Grinspun 2007]</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">crouzeix_raviart_massmatrix_known_e</span> <span class="o">=</span> <span class="n">crouzeix_raviart_massmatrix_known_e</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array"><strong><code class="codehilite"><span class="n">crouzeix_raviart_massmatrix_known_e</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">emap</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array" title="Permanent link">&para;</a></h3>
<p>wrapper if E and EMAP are already computed (better match!)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td></td>
</tr>
<tr>
<td>Returns</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">cylinder</span> <span class="o">=</span> <span class="n">cylinder</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="cylinderaxis_devisions-int-height_devisions-int"><strong><code class="codehilite"><span class="n">cylinder</span><span class="p">(</span><span class="n">axis_devisions</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">height_devisions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#cylinderaxis_devisions-int-height_devisions-int" title="Permanent link">&para;</a></h3>
<p>Construct a triangle mesh of a cylinder (without caps)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>axis_devisions  number of vertices <em>around the cylinder</em></br>height_devisions  number of vertices <em>up the cylinder</em></td>
</tr>
<tr>
<td>Returns</td>
<td>V  #V by 3 list of mesh vertex positions</br>F  #F by 3 list of triangle indices into V</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">decimate</span> <span class="o">=</span> <span class="n">decimate</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="decimatev-array-f-array-max_m-int"><strong><code class="codehilite"><span class="n">decimate</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">max_m</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#decimatev-array-f-array-max_m-int" title="Permanent link">&para;</a></h3>
<p>Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges
until desired number of faces is achieved. This uses default edge cost and
merged vertex placement functions {edge length, edge midpoint}.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of vertex positions</br>F  #F by 3 list of face indices into V.</br>max_m  desired number of output faces</td>
</tr>
<tr>
<td>Returns</td>
<td>U  #U by dim list of output vertex posistions (can be same ref as V)</br>G  #G by 3 list of output face indices into U (can be same ref as G)</br>J  #G list of indices into F of birth face</br>I  #U list of indices into V of birth vertices</br>Returns true if m was reached (otherwise #G &gt; m)</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">dihedral_angles</span> <span class="o">=</span> <span class="n">dihedral_angles</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="dihedral_anglesv-array-t-array"><strong><code class="codehilite"><span class="n">dihedral_angles</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#dihedral_anglesv-array-t-array" title="Permanent link">&para;</a></h3>
<p>Compute dihedral angles for all tets of a given tet mesh (v, t).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim list of vertex positions</br>t : #v by 4 list of tet indices</td>
</tr>
<tr>
<td>Returns</td>
<td>theta : #t by 6 list of dihedral angles (in radians)</br>cos_theta : #t by 6 list of cosine of dihedral angles (in radians)</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># TetMesh in (v, t)</span>
 <span class="n">theta</span><span class="p">,</span> <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">dihedral_angles</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">dihedral_angles_intrinsic</span> <span class="o">=</span> <span class="n">dihedral_angles_intrinsic</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="dihedral_angles_intrinsicl-array-a-array"><strong><code class="codehilite"><span class="n">dihedral_angles_intrinsic</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#dihedral_angles_intrinsicl-array-a-array" title="Permanent link">&para;</a></h3>
<p>See dihedral_angles for the documentation.
igl.directed_edge_parents = directed_edge_parents(&hellip;) method of builtins.PyCapsule instance</p>
<h3 id="directed_edge_parentse-array"><strong><code class="codehilite"><span class="n">directed_edge_parents</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#directed_edge_parentse-array" title="Permanent link">&para;</a></h3>
<p>Recover &ldquo;parents&rdquo; (preceding edges) in a tree given just directed edges.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>e : #e by 2 list of directed edges</td>
</tr>
<tr>
<td>Returns</td>
<td>p : #e list of parent indices into e. (-1) means root</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">e</span><span class="o">.</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">directed_edge_parents</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span> <span class="o">=</span> <span class="n">doublearea</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="doubleareav-array-f-array"><strong><code class="codehilite"><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#doubleareav-array-f-array" title="Permanent link">&para;</a></h3>
<p>Computes twice the area for each input triangle[quad]</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim array of mesh vertex positions</br>f : #f by simplex_size array of mesh faces (must be triangles or quads)</td>
</tr>
<tr>
<td>Returns</td>
<td>d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input)</td>
</tr>
<tr>
<td>Notes</td>
<td>Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">dbl_area</span> <span class="o">=</span> <span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">ears</span> <span class="o">=</span> <span class="n">ears</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="earsf-array"><strong><code class="codehilite"><span class="n">ears</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#earsf-array" title="Permanent link">&para;</a></h3>
<p>FIND_EARS  Find all ears (faces with two boundary edges) in a given mesh</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>F  #F by 3 list of triangle mesh indices</td>
</tr>
<tr>
<td>Returns</td>
<td>ears  #ears list of indices into F of ears</br>ear_opp  #ears list of indices indicating which edge is non-boundary</br>(connecting to flops)</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">ears</span><span class="p">,</span><span class="n">ear_opp</span> <span class="o">=</span> <span class="n">find_ears</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">edge_topology</span> <span class="o">=</span> <span class="n">edge_topology</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="edge_topologyv-array-f-array"><strong><code class="codehilite"><span class="n">edge_topology</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#edge_topologyv-array-f-array" title="Permanent link">&para;</a></h3>
<p>Initialize Edges and their topological relations (assumes an edge-manifold mesh)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim, list of mesh vertex positions (unused)</br>f : #f by 3, list of triangle indices into V</td>
</tr>
<tr>
<td>Returns</td>
<td>ev : #e by 2, list of edges described as pair of vertices.</br>fe : #f by 3, list storing triangle-edge relation.</br>ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">ev</span><span class="p">,</span> <span class="n">fe</span><span class="p">,</span> <span class="n">ef</span> <span class="o">=</span> <span class="n">edge_topology</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="edgesf-array"><strong><code class="codehilite"><span class="n">edges</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#edgesf-array" title="Permanent link">&para;</a></h3>
<p>Constructs a list of unique edges represented in a given mesh (v, f)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : #F by dim list of mesh faces (must be triangles or tets)</td>
</tr>
<tr>
<td>Returns</td>
<td>#e by 2 list of edges in no particular order</td>
</tr>
<tr>
<td>See also</td>
<td>adjacency_matrix</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span> <span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">readOFF</span><span class="p">(</span><span class="s2">&quot;test.off)</span>
 <span class="n">E</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">euler_characteristic</span> <span class="o">=</span> <span class="n">euler_characteristic</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="euler_characteristicf-array-int"><strong><code class="codehilite"><span class="n">euler_characteristic</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span></code></strong><a class="headerlink" href="#euler_characteristicf-array-int" title="Permanent link">&para;</a></h3>
<p>Computes the Euler characteristic of a given mesh (V,F)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>F #F by dim list of mesh faces (must be triangles)</td>
</tr>
<tr>
<td>Returns</td>
<td>Returns An int containing the Euler characteristic</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">euler_characteristic_complete</span> <span class="o">=</span> <span class="n">euler_characteristic_complete</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="euler_characteristic_completev-array-f-array-int"><strong><code class="codehilite"><span class="n">euler_characteristic_complete</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span></code></strong><a class="headerlink" href="#euler_characteristic_completev-array-f-array-int" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V       #V by dim list of mesh vertex positions</td>
</tr>
<tr>
<td>Returns</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">exact_geodesic</span> <span class="o">=</span> <span class="n">exact_geodesic</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none"><strong><code class="codehilite"><span class="n">exact_geodesic</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">vs</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">vt</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="nb">array</span>  <span class="k">None</span> <span class="o">=</span> <span class="k">None</span><span class="p">,</span> <span class="n">ft</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="nb">array</span>  <span class="k">None</span> <span class="o">=</span> <span class="k">None</span><span class="p">)</span></code></strong><a class="headerlink" href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none" title="Permanent link">&para;</a></h3>
<p>Exact geodesic algorithm for the calculation of geodesics on a triangular mesh.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by 3 array of 3D vertex positions</br>f : #f by 3 array of mesh faces</br>vs : #vs by 1 array specifying indices of source vertices</br>fs : #fs by 1 array specifying indices of source faces</br>vt : #vt by 1 array specifying indices of target vertices</br>ft : #ft by 1 array specifying indices of target faces</td>
</tr>
<tr>
<td>Returns</td>
<td>d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set</td>
</tr>
<tr>
<td>Notes</td>
<td>Specifying a face as target/source means its center.</br>Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">face_components</span> <span class="o">=</span> <span class="n">face_components</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="face_componentsf-array"><strong><code class="codehilite"><span class="n">face_components</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#face_componentsf-array" title="Permanent link">&para;</a></h3>
<p>Compute connected components of facets based on edge-edge adjacency,</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : #f x 3 array of triangle indices</td>
</tr>
<tr>
<td>Returns</td>
<td>An array, c, with shape (#f,), of component ids</td>
</tr>
<tr>
<td>See also</td>
<td>vertex_components</br>vertex_components_from_adjacency_matrix</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">fit_plane</span> <span class="o">=</span> <span class="n">fit_plane</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="fit_planev-array"><strong><code class="codehilite"><span class="n">fit_plane</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#fit_planev-array" title="Permanent link">&para;</a></h3>
<p>This function fits a plane to a point cloud.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V #Vx3 matrix. The 3D point cloud, one row for each vertex.</td>
</tr>
<tr>
<td>Returns</td>
<td>N 1x3 Vector. The normal of the fitted plane.</br>C 1x3 Vector. A point that lies in the fitted plane.</td>
</tr>
<tr>
<td>Notes</td>
<td>From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">gaussian_curvature</span> <span class="o">=</span> <span class="n">gaussian_curvature</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="gaussian_curvaturev-array-f-array"><strong><code class="codehilite"><span class="n">gaussian_curvature</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#gaussian_curvaturev-array-f-array" title="Permanent link">&para;</a></h3>
<p>Compute discrete local integral gaussian curvature (angle deficit, without
averaging by local area).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by 3 array of mesh vertex 3D positions</br>f : #f by 3 array of face (triangle) indices</td>
</tr>
<tr>
<td>Returns</td>
<td>k : #v by 1 array of discrete gaussian curvature values</td>
</tr>
<tr>
<td>See also</td>
<td>principal_curvature</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">k</span> <span class="o">=</span> <span class="n">gaussian_curvature</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="gradv-array-f-array-uniform-bool-false"><strong><code class="codehilite"><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">uniform</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="k">False</span><span class="p">)</span></code></strong><a class="headerlink" href="#gradv-array-f-array-uniform-bool-false" title="Permanent link">&para;</a></h3>
<p>Compute the numerical gradient operator.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by 3 list of mesh vertex positions</br>f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices]</br>uniform : boolean (default false). Use a uniform mesh instead of the vertices v</td>
</tr>
<tr>
<td>Returns</td>
<td>g : #faces * dim by #v gradient operator</td>
</tr>
<tr>
<td>See also</td>
<td>cotmatrix, massmatrix</td>
</tr>
<tr>
<td>Notes</td>
<td>Gradient of a scalar function defined on piecewise linear elements (mesh)</br>is constant on each triangle [tetrahedron] i,j,k:</br>grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A</br>where Xi is the scalar value at vertex i, Vi is the 3D position of vertex</br>i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of</br>90 degrees.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">g</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">harmonic_integrated_with_laplacian</span> <span class="o">=</span> <span class="n">harmonic_integrated_with_laplacian</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="harmonic_integrated_with_laplacianl-sparse_matrix-m-sparse_matrix-k-int"><strong><code class="codehilite"><span class="n">harmonic_integrated_with_laplacian</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">sparse_matrix</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">sparse_matrix</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#harmonic_integrated_with_laplacianl-sparse_matrix-m-sparse_matrix-k-int" title="Permanent link">&para;</a></h3>
<p>Build the discrete k-harmonic operator (computing integrated quantities).
That is, if the k-harmonic PDE is Q x = 0, then this minimizes x&rsquo; Q x</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>L  #V by #V discrete (integrated) Laplacian</br>M  #V by #V mass matrix</br>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</td>
</tr>
<tr>
<td>Returns</td>
<td>Q  #V by #V discrete (integrated) k-Laplacian</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">harmonic_uniform_laplacian</span> <span class="o">=</span> <span class="n">harmonic_uniform_laplacian</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="harmonic_uniform_laplacianf-array-b-array-bc-array-k-int"><strong><code class="codehilite"><span class="n">harmonic_uniform_laplacian</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">bc</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int" title="Permanent link">&para;</a></h3>
<p>Compute harmonic map using uniform laplacian operator</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>F  #F by simplex-size list of element indices</br>b  #b boundary indices into V</br>bc #b by #W list of boundary values</br>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</td>
</tr>
<tr>
<td>Returns</td>
<td>W  #V by #W list of weights</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">harmonic_weights</span> <span class="o">=</span> <span class="n">harmonic_weights</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="harmonic_weightsv-array-f-array-b-array-bc-array-k-int"><strong><code class="codehilite"><span class="n">harmonic_weights</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">bc</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int" title="Permanent link">&para;</a></h3>
<p>Compute k-harmonic weight functions &ldquo;coordinates&rdquo;.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim vertex positions</br>F  #F by simplex-size list of element indices</br>b  #b boundary indices into V</br>bc #b by #W list of boundary values</br>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</td>
</tr>
<tr>
<td>Returns</td>
<td>W  #V by #W list of weights</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">internal_angles</span> <span class="o">=</span> <span class="n">internal_angles</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="internal_anglesv-array-f-array"><strong><code class="codehilite"><span class="n">internal_angles</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#internal_anglesv-array-f-array" title="Permanent link">&para;</a></h3>
<p>Computes internal angles for a triangle mesh.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim array of mesh vertex nD positions</br>f : #f by poly-size array of face (triangle) indices</td>
</tr>
<tr>
<td>Returns</td>
<td>k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1].</td>
</tr>
<tr>
<td>Notes</td>
<td>If poly-size  3 then dim must equal 3.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">is_edge_manifold</span> <span class="o">=</span> <span class="n">is_edge_manifold</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="is_edge_manifoldf-array-bool"><strong><code class="codehilite"><span class="n">is_edge_manifold</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool</span></code></strong><a class="headerlink" href="#is_edge_manifoldf-array-bool" title="Permanent link">&para;</a></h3>
<p>See is_edge_manifold for the documentation.
igl.is_irregular_vertex = is_irregular_vertex(&hellip;) method of builtins.PyCapsule instance</p>
<h3 id="is_irregular_vertexv-array-f-array-listbool"><strong><code class="codehilite"><span class="n">is_irregular_vertex</span><span class="p">(</span><span class="nl">v</span><span class="p">:</span><span class="w"> </span><span class="k">array</span><span class="p">,</span><span class="w"> </span><span class="nl">f</span><span class="p">:</span><span class="w"> </span><span class="k">array</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">List</span><span class="o">[</span><span class="n">bool</span><span class="o">]</span><span class="w"></span></code></strong><a class="headerlink" href="#is_irregular_vertexv-array-f-array-listbool" title="Permanent link">&para;</a></h3>
<p>Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim array of vertex positions</br>f : #f by 3[4] array of triangle[quads] indices</td>
</tr>
<tr>
<td>Returns</td>
<td>s : #v list of bools revealing whether vertices are singular</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">isolines</span> <span class="o">=</span> <span class="n">isolines</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="isolinesv-array-f-array-z-array-n-int"><strong><code class="codehilite"><span class="n">isolines</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#isolinesv-array-f-array-z-array-n-int" title="Permanent link">&para;</a></h3>
<p>Constructs isolines for a function z given on a mesh (V,F)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of mesh vertex positions</br>F  #F by 3 list of mesh faces (must be triangles)</br>z  #V by 1 list of function values evaluated at vertices</br>n  the number of desired isolines</td>
</tr>
<tr>
<td>Returns</td>
<td>isoV  #isoV by dim list of isoline vertex positions</br>isoE  #isoE by 2 list of isoline edge positions</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span> <span class="o">=</span> <span class="n">massmatrix</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="massmatrixv-array-f-array-type-int-1"><strong><code class="codehilite"><span class="n">massmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="k">type</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span></code></strong><a class="headerlink" href="#massmatrixv-array-f-array-type-int-1" title="Permanent link">&para;</a></h3>
<p>Constructs the mass (area) matrix for a given mesh (V,F).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by dim list of mesh vertex positions</br>f : #f by simplex_size list of mesh faces (must be triangles)</br>type : one of the following types:</br>-igl.MASSMATRIX_TYPE_BARYCENTRIC  barycentric</br>-igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default)</br>-igl.MASSMATRIX_TYPE_FULL full (not implemented)</td>
</tr>
<tr>
<td>Returns</td>
<td>m : #v by #v mass matrix</td>
</tr>
<tr>
<td>See also</td>
<td>adjacency_matrix, cotmatrix, grad</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">min_quad_dense_precompute</span> <span class="o">=</span> <span class="n">min_quad_dense_precompute</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool"><strong><code class="codehilite"><span class="n">min_quad_dense_precompute</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">aeq</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">use_lu_decomposition</span><span class="p">:</span> <span class="n">bool</span><span class="p">)</span></code></strong><a class="headerlink" href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool" title="Permanent link">&para;</a></h3>
<p>MIN_QUAD_WITH_FIXED Minimize quadratic energy Z&rsquo;*A*Z + Z&rsquo;*B + C
subject to linear constraints Aeq*Z = Beq</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>A  n by n matrix of quadratic coefficients</br>B  n by 1 column of linear coefficients</br>Aeq  m by n list of linear equality constraint coefficients</br>Beq  m by 1 list of linear equality constraint constant values</br>use_lu_decomposition  use lu rather than SVD</td>
</tr>
<tr>
<td>Returns</td>
<td>S  n by (n + m) &ldquo;solve&rdquo; matrix, such that S*[B&rsquo;, Beq&rsquo;] is a solution</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">orientable_patches</span> <span class="o">=</span> <span class="n">orientable_patches</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="orientable_patchesf-array"><strong><code class="codehilite"><span class="n">orientable_patches</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#orientable_patchesf-array" title="Permanent link">&para;</a></h3>
<p>Compute connected components of facets connected by manifold edges.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : n by dim array of face ids</td>
</tr>
<tr>
<td>Returns</td>
<td>A tuple (c, A) where c is an array of component ids (starting with 0)</br>and A is a #f x #f adjacency matri</td>
</tr>
<tr>
<td>See also</td>
<td>components</td>
</tr>
<tr>
<td>Notes</td>
<td>Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">oriented_facets</span> <span class="o">=</span> <span class="n">oriented_facets</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="oriented_facetsf-array"><strong><code class="codehilite"><span class="n">oriented_facets</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#oriented_facetsf-array" title="Permanent link">&para;</a></h3>
<p>Determines all &lsquo;directed <a href="https:en.wikipedia.org/wiki/Simplex#Elements">facets</a>&lsquo; of a given set
of simplicial elements. For a manifold triangle mesh, this computes all half-edges.
For a manifold tetrahedral mesh, this computes all half-faces.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : #F by simplex_size list of simplices</td>
</tr>
<tr>
<td>Returns</td>
<td>#E : by simplex_size-1 list of half-edges/facets</td>
</tr>
<tr>
<td>See also</td>
<td>edges</td>
</tr>
<tr>
<td>Notes</td>
<td>This is not the same as igl::edges because this includes every</br>directed edge including repeats (meaning interior edges on a surface will</br>show up once for each direction and non-manifold edges may appear more than</br>once for each direction).</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">per_edge_normals</span> <span class="o">=</span> <span class="n">per_edge_normals</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="per_edge_normalsv-array-f-array-weight-int-0-fn-array"><strong><code class="codehilite"><span class="n">per_edge_normals</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#per_edge_normalsv-array-f-array-weight-int-0-fn-array" title="Permanent link">&para;</a></h3>
<p>Compute face normals via vertex position list, face list</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by 3 eigen Matrix of mesh vertex 3D positions</br>F  #F by 3 eigen Matrix of face (triangle) indices</br>weight  weighting type</br>FN  #F by 3 matrix of 3D face normals per face</td>
</tr>
<tr>
<td>Returns</td>
<td>N  #2 by 3 matrix of mesh edge 3D normals per row</br>E  #E by 2 matrix of edge indices per row</br>EMAP  #E by 1 matrix of indices from all edges to E</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">per_face_normals</span> <span class="o">=</span> <span class="n">per_face_normals</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="per_face_normalsv-array-f-array-z-array"><strong><code class="codehilite"><span class="n">per_face_normals</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#per_face_normalsv-array-f-array-z-array" title="Permanent link">&para;</a></h3>
<p>Compute face normals via vertex position list, face list</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by 3 eigen Matrix of mesh vertex 3D positions</br>F  #F by 3 eigen Matrix of face (triangle) indices</br>Z  3 vector normal given to faces with degenerate normal.</td>
</tr>
<tr>
<td>Returns</td>
<td>N  #F by 3 eigen Matrix of mesh face (triangle) 3D normals</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">Give</span> <span class="n">degenerate</span> <span class="n">faces</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mf">0.5</span>
</pre></div></p>
<h3 id="per_face_normalsvfvector3d111normalizedn"><strong><code class="codehilite"><span class="n">per_face_normals</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span><span class="n">normalized</span><span class="p">(),</span><span class="n">N</span><span class="p">);</span></code></strong><a class="headerlink" href="#per_face_normalsvfvector3d111normalizedn" title="Permanent link">&para;</a></h3>
<p>igl.per_vertex_attribute_smoothing = per_vertex_attribute_smoothing(&hellip;) method of builtins.PyCapsule instance</p>
<h3 id="per_vertex_attribute_smoothingain-array-f-array"><strong><code class="codehilite"><span class="n">per_vertex_attribute_smoothing</span><span class="p">(</span><span class="n">ain</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#per_vertex_attribute_smoothingain-array-f-array" title="Permanent link">&para;</a></h3>
<p>Smooth vertex attributes using uniform Laplacian</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>Ain  #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes)</br>F    #F by 3 eigne Matrix of face (triangle) indices</td>
</tr>
<tr>
<td>Returns</td>
<td>Aout #V by #A eigen Matrix of mesh vertex attributes</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">per_vertex_normals</span> <span class="o">=</span> <span class="n">per_vertex_normals</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="per_vertex_normalsv-array-f-array-weighting-int-0"><strong><code class="codehilite"><span class="n">per_vertex_normals</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">weighting</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span></code></strong><a class="headerlink" href="#per_vertex_normalsv-array-f-array-weighting-int-0" title="Permanent link">&para;</a></h3>
<p>Compute vertex normals via vertex position list, face list.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by 3 array of mesh vertex 3D positions</br>f : #f by 3 array of face (triangle) indices</br>weighting : Weighting type, one of the following</br>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence</br>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted</br>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted</td>
</tr>
<tr>
<td>Returns</td>
<td>n  #v by 3 array of mesh vertex 3D normals</td>
</tr>
<tr>
<td>See also</td>
<td>per_face_normals, per_edge_normals</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">n</span> <span class="o">=</span> <span class="n">per_vertex_normals</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">piecewise_constant_winding_number</span> <span class="o">=</span> <span class="n">piecewise_constant_winding_number</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="piecewise_constant_winding_numberf-array-bool"><strong><code class="codehilite"><span class="n">piecewise_constant_winding_number</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool</span></code></strong><a class="headerlink" href="#piecewise_constant_winding_numberf-array-bool" title="Permanent link">&para;</a></h3>
<p>PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a
piecewise constant winding number field: Is this mesh valid input to solid
set operations.  <strong>Assumes</strong> that <code class="codehilite"><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">)</span></code> contains no -intersections
(including degeneracies and co-incidences).  If there are co-planar and
co-incident vertex placements, a mesh could <em>fail</em> this combinatorial test
but still induce a piecewise-constant winding number <em>geometrically</em>. For
example, consider a hemisphere with boundary and then pinch the boundary
&ldquo;shut&rdquo; along a line segment. The <strong><em>bullet-proof</em></strong> check is to first
resolve all -intersections in <code class="codehilite"><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">SV</span><span class="p">,</span><span class="n">SF</span><span class="p">)</span></code> (i.e. what the
<code class="codehilite"><span class="n">igl</span><span class="p">::</span><span class="n">copyleft</span><span class="p">::</span><span class="n">cgal</span><span class="p">::</span><span class="n">piecewise_constant_winding_number</span></code> overload does).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>F  #F by 3 list of triangle indices into some (abstract) list of</br>vertices V</td>
</tr>
<tr>
<td>Returns</td>
<td>Returns true if the mesh <em>combinatorially</em> induces a piecewise constant</br>winding number field.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">principal_curvature</span> <span class="o">=</span> <span class="n">principal_curvature</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true"><strong><code class="codehilite"><span class="n">principal_curvature</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">use_k_ring</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="k">True</span><span class="p">)</span></code></strong><a class="headerlink" href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true" title="Permanent link">&para;</a></h3>
<p>Compute the principal curvature directions and magnitude of the given triangle mesh.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : vertex array of size #V by 3</br>f : face index array #F by 3 list of mesh faces (must be triangles)</br>radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5)</br>use_k_ring : (default: True)</td>
</tr>
<tr>
<td>Returns</td>
<td>pd1 : #v by 3 maximal curvature direction for each vertex</br>pd2 : #v by 3 minimal curvature direction for each vertex</br>pv1 : #v by 1 maximal curvature value for each vertex</br>pv2 : #v by 1 minimal curvature value for each vertex</td>
</tr>
<tr>
<td>See also</td>
<td>average_onto_faces, average_onto_vertices</td>
</tr>
<tr>
<td>Notes</td>
<td>This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo.</br>The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation</br>Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">pd1</span><span class="p">,</span> <span class="n">pd2</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span> <span class="o">=</span> <span class="n">principal_curvature</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">procrustes</span> <span class="o">=</span> <span class="n">procrustes</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="procrustesx-array-y-array-include_scaling-bool-include_reflections-bool"><strong><code class="codehilite"><span class="n">procrustes</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">include_scaling</span><span class="p">:</span> <span class="n">bool</span><span class="p">,</span> <span class="n">include_reflections</span><span class="p">:</span> <span class="n">bool</span><span class="p">)</span></code></strong><a class="headerlink" href="#procrustesx-array-y-array-include_scaling-bool-include_reflections-bool" title="Permanent link">&para;</a></h3>
<p>Solve Procrustes problem in d dimensions.  Given two point sets X,Y in R^d
find best scale s, orthogonal R  and translation t s.t. s*X*R + t - Y^2
is minimized.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>X  #V by DIM first list of points</br>Y  #V by DIM second list of points</br>includeScaling  if scaling should be allowed</br>includeReflections  if R is allowed to be a reflection</td>
</tr>
<tr>
<td>Returns</td>
<td>scale  scaling</br>R      orthogonal matrix</br>t      translation</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">MatrixXd</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">;</span> <span class="p">(</span><span class="n">containing</span> <span class="mi">3</span><span class="n">d</span> <span class="n">points</span> <span class="k">as</span> <span class="n">rows</span><span class="p">)</span>
<span class="n">double</span> <span class="n">scale</span><span class="p">;</span>
<span class="n">MatrixXd</span> <span class="n">R</span><span class="p">;</span>
<span class="n">VectorXd</span> <span class="n">t</span><span class="p">;</span>
<span class="n">igl</span><span class="p">::</span><span class="n">procrustes</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">true</span><span class="p">,</span><span class="n">false</span><span class="p">,</span><span class="n">scale</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
<span class="n">R</span> <span class="o">*=</span> <span class="n">scale</span><span class="p">;</span>
<span class="n">MatrixXd</span> <span class="n">Xprime</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">rowwise</span><span class="p">()</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">transpose</span><span class="p">();</span>
<span class="n">igl</span><span class="o">.</span><span class="n">qslim</span> <span class="o">=</span> <span class="n">qslim</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="qslimv-array-f-array-max_m-int"><strong><code class="codehilite"><span class="n">qslim</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">max_m</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#qslimv-array-f-array-max_m-int" title="Permanent link">&para;</a></h3>
<p>Decimate (simplify) a triangle mesh in nD according to the paper
&ldquo;Simplifying Surfaces with Color and Texture using Quadric Error Metrics&rdquo;
by [Garland and Heckbert, 1987] (technically a followup to qslim). The
mesh can have open boundaries but should be edge-manifold.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of vertex positions. Assumes that vertices w</br>F  #F by 3 list of triangle indices into V</br>max_m  desired number of output faces</td>
</tr>
<tr>
<td>Returns</td>
<td>U  #U by dim list of output vertex posistions (can be same ref as V)</br>G  #G by 3 list of output face indices into U (can be same ref as G)</br>J  #G list of indices into F of birth face</br>I  #U list of indices into V of birth vertices</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">quad_planarity</span> <span class="o">=</span> <span class="n">quad_planarity</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="quad_planarityv-array-f-array"><strong><code class="codehilite"><span class="n">quad_planarity</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#quad_planarityv-array-f-array" title="Permanent link">&para;</a></h3>
<p>Compute planarity of the faces of a quad mesh.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by 3 array of mesh vertex 3D positions</br>f : #f by 4 array of face (quad) indices</td>
</tr>
<tr>
<td>Returns</td>
<td>p : #f by 1 array of mesh face (quad) planarities</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">random_points_on_mesh</span> <span class="o">=</span> <span class="n">random_points_on_mesh</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="random_points_on_meshn-int-v-array-f-array"><strong><code class="codehilite"><span class="n">random_points_on_mesh</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#random_points_on_meshn-int-v-array-f-array" title="Permanent link">&para;</a></h3>
<p>RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>n  number of samples</br>V  #V by dim list of mesh vertex positions</br>F  #F by 3 list of mesh triangle indices</td>
</tr>
<tr>
<td>Returns</td>
<td>B  n by 3 list of barycentric coordinates, ith row are coordinates of</br>ith sampled point in face FI(i)</br>FI  n list of indices into F</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">read_dmat</span> <span class="o">=</span> <span class="n">read_dmat</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="read_dmatfilename-str-dtype-dtype-float64"><strong><code class="codehilite"><span class="n">read_dmat</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span></code></strong><a class="headerlink" href="#read_dmatfilename-str-dtype-dtype-float64" title="Permanent link">&para;</a></h3>
<p>Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always:
&lt;#columns&gt; &lt;#rows&gt;
Then the coefficients of the matrix are given separated by whitespace with columns running fastest.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>filename : string, path to .dmat file</br>dtype : data-type of the returned matrix. Default is <code class="codehilite"><span class="n">float64</span></code>.</br>(returned faces always have type int32.)</td>
</tr>
<tr>
<td>Returns</td>
<td>w : array containing read-in coefficients</td>
</tr>
<tr>
<td>See also</td>
<td>read_triangle_mesh, read_off</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span> <span class="n">w</span> <span class="o">=</span> <span class="n">read_dmat</span><span class="p">(</span><span class="s2">&quot;my_model.dmat&quot;</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">read_obj</span> <span class="o">=</span> <span class="n">read_obj</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="read_objfilename-str-dtype-dtype-float64"><strong><code class="codehilite"><span class="n">read_obj</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span></code></strong><a class="headerlink" href="#read_objfilename-str-dtype-dtype-float64" title="Permanent link">&para;</a></h3>
<p>Read a mesh from an ascii obj file, filling in vertex positions, normals
and texture coordinates. Mesh may have faces of any number of degree.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>filename : string, path to .obj file</br>dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is <code class="codehilite"><span class="n">float64</span></code>.</br>(returned faces always have type int32.)</td>
</tr>
<tr>
<td>Returns</td>
<td>v : array of vertex positions #v by 3</br>tc : array of texture coordinats #tc by 2</br>n : array of corner normals #n by 3</br>f : #f array of face indices into vertex positions</br>ftc : #f array of face indices into vertex texture coordinates</br>fn : #f array of face indices into vertex normals</td>
</tr>
<tr>
<td>See also</td>
<td>read_triangle_mesh, read_off</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">read_obj</span><span class="p">(</span><span class="s2">&quot;my_model.obj&quot;</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">read_off</span> <span class="o">=</span> <span class="n">read_off</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="read_offfilename-str-read_normals-bool-true-dtype-dtype-float64"><strong><code class="codehilite"><span class="n">read_off</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">read_normals</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="k">True</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span></code></strong><a class="headerlink" href="#read_offfilename-str-read_normals-bool-true-dtype-dtype-float64" title="Permanent link">&para;</a></h3>
<p>Read a mesh from an ascii off file, filling in vertex positions, normals
and texture coordinates. Mesh may have faces of any number of degree.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>filename : string, path to .off file</br>read_normals : bool, determines whether normals are read. If false, returns []</br>dtype : data-type of the returned vertices, faces, and normals, optional. Default is <code class="codehilite"><span class="n">float64</span></code>.</br>(returned faces always have type int32.)</td>
</tr>
<tr>
<td>Returns</td>
<td>v : array of vertex positions #v by 3</br>f : #f list of face indices into vertex positions</br>n : list of vertex normals #v by 3</td>
</tr>
<tr>
<td>See also</td>
<td>read_triangle_mesh, read_obj</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">read_off</span><span class="p">(</span><span class="s2">&quot;my_model.off&quot;</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span> <span class="o">=</span> <span class="n">read_triangle_mesh</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="read_triangle_meshfilename-str-dtype-dtype-float64"><strong><code class="codehilite"><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span></code></strong><a class="headerlink" href="#read_triangle_meshfilename-str-dtype-dtype-float64" title="Permanent link">&para;</a></h3>
<p>Read mesh from an ascii file with automatic detection of file format.
Supported: obj, off, stl, wrl, ply, mesh.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>filename : string, path to mesh file</br>dtype : data-type of the returned vertices, optional. Default is <code class="codehilite"><span class="n">float64</span></code>.</br>(returned faces always have type int32.)</td>
</tr>
<tr>
<td>Returns</td>
<td>v : array of vertex positions #v by 3</br>f : #f list of face indices into vertex positions</td>
</tr>
<tr>
<td>See also</td>
<td>read_obj, read_off, read_stl</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;my_model.obj&quot;</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">remove_duplicate_vertices</span> <span class="o">=</span> <span class="n">remove_duplicate_vertices</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="remove_duplicate_verticesv-array-f-array-epsilon-float"><strong><code class="codehilite"><span class="n">remove_duplicate_vertices</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span></code></strong><a class="headerlink" href="#remove_duplicate_verticesv-array-f-array-epsilon-float" title="Permanent link">&para;</a></h3>
<p>REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness
tolerance (epsilon)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of vertex positions</br>epsilon  uniqueness tolerance (significant digit), can probably think of</br>this as a tolerance on L1 distance</td>
</tr>
<tr>
<td>Returns</td>
<td>SV  #SV by dim new list of vertex positions</br>SVI #V by 1 list of indices so SV = V(SVI,:)</br>SVJ #SV by 1 list of indices so V = SV(SVJ,:)</br>Wrapper that also remaps given faces (F) &rarr; (SF) so that SF index SV</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="o">%</span> <span class="n">Mesh</span> <span class="ow">in</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">)</span>
<span class="p">[</span><span class="n">SV</span><span class="p">,</span><span class="n">SVI</span><span class="p">,</span><span class="n">SVJ</span><span class="p">]</span> <span class="o">=</span> <span class="n">remove_duplicate_vertices</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">);</span>
<span class="o">%</span> <span class="n">remap</span> <span class="n">faces</span>
<span class="n">SF</span> <span class="o">=</span> <span class="n">SVJ</span><span class="p">(</span><span class="n">F</span><span class="p">);</span>
<span class="n">igl</span><span class="o">.</span><span class="n">remove_duplicates</span> <span class="o">=</span> <span class="n">remove_duplicates</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="remove_duplicatesv-array-f-array-epsilon-float"><strong><code class="codehilite"><span class="n">remove_duplicates</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span></code></strong><a class="headerlink" href="#remove_duplicatesv-array-f-array-epsilon-float" title="Permanent link">&para;</a></h3>
<p>Merge the duplicate vertices from V, fixing the topology accordingly</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V,F       mesh description</br>epsilon   minimal distance to consider two vertices identical</td>
</tr>
<tr>
<td>Returns</td>
<td>NV, NF    new mesh without duplicate vertices</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">remove_unreferenced</span> <span class="o">=</span> <span class="n">remove_unreferenced</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="remove_unreferencedv-array-f-array"><strong><code class="codehilite"><span class="n">remove_unreferenced</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#remove_unreferencedv-array-f-array" title="Permanent link">&para;</a></h3>
<p>Remove unreferenced vertices from V, updating F accordingly</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim list of mesh vertex positions</br>F  #F by ss list of simplices (Values of -1 are quitely skipped)</td>
</tr>
<tr>
<td>Returns</td>
<td>NV  #NV by dim list of mesh vertex positions</br>NF  #NF by ss list of simplices</br>IM  #V by 1 list of indices such that: NF = IM(F) and NT = IM(T)</br>and V(find(IM&lt;=size(NV,1)),:) = NV</br>J  #RV by 1 list, such that RV = V(J,:)</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">resolve_duplicated_faces</span> <span class="o">=</span> <span class="n">resolve_duplicated_faces</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="resolve_duplicated_facesf1-array"><strong><code class="codehilite"><span class="n">resolve_duplicated_faces</span><span class="p">(</span><span class="n">f1</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#resolve_duplicated_facesf1-array" title="Permanent link">&para;</a></h3>
<p>Resolve duplicated faces according to the following rules per unique face:</p>
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of"><strong><code class="codehilite"><span class="k">If</span> <span class="nv">the</span> <span class="nv">number</span> <span class="nv">of</span> <span class="nv">positively</span> <span class="nv">oriented</span> <span class="nv">faces</span> <span class="nv">equals</span> <span class="nv">the</span> <span class="nv">number</span> <span class="nv">of</span></code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces, remove all duplicated faces at this triangle.</p>
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_1"><strong><code class="codehilite"><span class="k">If</span> <span class="nv">the</span> <span class="nv">number</span> <span class="nv">of</span> <span class="nv">positively</span> <span class="nv">oriented</span> <span class="nv">faces</span> <span class="nv">equals</span> <span class="nv">the</span> <span class="nv">number</span> <span class="nv">of</span></code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_1" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces plus 1, keeps one of the positively oriented
face.</p>
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_2"><strong><code class="codehilite"><span class="k">If</span> <span class="nv">the</span> <span class="nv">number</span> <span class="nv">of</span> <span class="nv">positively</span> <span class="nv">oriented</span> <span class="nv">faces</span> <span class="nv">equals</span> <span class="nv">the</span> <span class="nv">number</span> <span class="nv">of</span></code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_2" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces minus 1, keeps one of the negatively oriented
face.</p>
<h3 id="if-the-number-of-postively-oriented-faces-differ-with-the-number-of"><strong><code class="codehilite"><span class="k">If</span> <span class="nv">the</span> <span class="nv">number</span> <span class="nv">of</span> <span class="nv">postively</span> <span class="nv">oriented</span> <span class="nv">faces</span> <span class="nv">differ</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">number</span> <span class="nv">of</span></code></strong><a class="headerlink" href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of" title="Permanent link">&para;</a></h3>
<p>negativley oriented faces by more than 1, the mesh is not orientable.
An exception will be thrown.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>F1  #F1 by 3 array of input faces.</td>
</tr>
<tr>
<td>Returns</td>
<td>F2  #F2 by 3 array of output faces without duplicated faces.</br>J   #F2 list of indices into F1.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">shape_diameter_function</span> <span class="o">=</span> <span class="n">shape_diameter_function</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int"><strong><code class="codehilite"><span class="n">shape_diameter_function</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int" title="Permanent link">&para;</a></h3>
<p>Compute shape diamater function per given point. In the parlence of the
paper &ldquo;Consistent Mesh Partitioning and Skeletonisation using the Shape
Diameter Function&rdquo; [Shapiro et al. 2008], this implementation uses a 180
cone and a <em>uniform</em> average (<em>not</em> a average weighted by inverse angles).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by 3 list of mesh vertex positions</br>F  #F by 3 list of mesh face indices into V</br>P  #P by 3 list of origin points</br>N  #P by 3 list of origin normals</td>
</tr>
<tr>
<td>Returns</td>
<td>S  #P list of shape diamater function values between bounding box</br>diagonal (perfect sphere) and 0 (perfect needle hook)</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">sort_angles</span> <span class="o">=</span> <span class="n">sort_angles</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="sort_anglesm-array"><strong><code class="codehilite"><span class="n">sort_angles</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#sort_anglesm-array" title="Permanent link">&para;</a></h3>
<p>Sort angles in ascending order in a numerically robust way.
Instead of computing angles using atan2(y, x), sort directly on (y, x).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>M: m by n matrix of scalars. (n &gt;= 2).  Assuming the first column of M</br>contains values for y, and the second column is x.  Using the rest</br>of the columns as tie-breaker.</td>
</tr>
<tr>
<td>Returns</td>
<td>R: an array of m indices.  M.row(R[i]) contains the i-th smallest</br>angle.</td>
</tr>
<tr>
<td>Notes</td>
<td>None.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">tet_tet_adjacency</span> <span class="o">=</span> <span class="n">tet_tet_adjacency</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="tet_tet_adjacencyt-array"><strong><code class="codehilite"><span class="n">tet_tet_adjacency</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#tet_tet_adjacencyt-array" title="Permanent link">&para;</a></h3>
<p>Constructs the tet_tet adjacency matrix for a given tet mesh with tets T</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>T  #T by 4 list of tets</td>
</tr>
<tr>
<td>Returns</td>
<td>TT   #T by #4 adjacency matrix, the element i,j is the id of the tet adjacent to the j face of tet i</br>TTi  #T by #4 adjacency matrix, the element i,j is the id of face of the tet TT(i,j) that is adjacent to tet i</td>
</tr>
<tr>
<td>Notes</td>
<td>the first face of a tet is [0,1,2], the second [0,1,3], the third [1,2,3], and the fourth [2,0,3].</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">tetrahedralize</span> <span class="o">=</span> <span class="n">tetrahedralize</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="tetrahedralizev-array-f-array-switches-str-pyq"><strong><code class="codehilite"><span class="n">tetrahedralize</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">switches</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="s1">&#39;pYQ&#39;</span><span class="p">)</span></code></strong><a class="headerlink" href="#tetrahedralizev-array-f-array-switches-str-pyq" title="Permanent link">&para;</a></h3>
<p>Mesh the interior of a surface mesh (V,F) using tetgen.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by 3 vertex position array</br>f : #v array of polygon face indices into V (0-indexed)</br>switches : string of tetgen options (See tetgen documentation) e.g.</br>&ldquo;pq1.414a0.01&rdquo; tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F)</td>
</tr>
<tr>
<td>Returns</td>
<td>tv  #v by 3 vertex position array</br>tt  #t by 4 array of tet face indices</br>tf  #f by 3 array of triangle face indices</td>
</tr>
<tr>
<td>Notes</td>
<td>Returns status:</br>0 success</br>1 tetgen threw exception</br>2 tetgen did not crash but could not create any tets (probably there are</br>holes, duplicate faces etc.)</br>-1 other error</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">triangle_triangle_adjacency</span> <span class="o">=</span> <span class="n">triangle_triangle_adjacency</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="triangle_triangle_adjacencyf-array"><strong><code class="codehilite"><span class="n">triangle_triangle_adjacency</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#triangle_triangle_adjacencyf-array" title="Permanent link">&para;</a></h3>
<p>Constructs the triangle-triangle adjacency matrix for a given
mesh (V,F).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>F  #F by simplex_size list of mesh faces (must be triangles)</td>
</tr>
<tr>
<td>Returns</td>
<td>TT   #F by #3 adjacent matrix, the element i,j is the id of the triangle</br>adjacent to the j edge of triangle i</br>TTi  #F by #3 adjacent matrix, the element i,j is the id of edge of the</br>triangle TT(i,j) that is adjacent with triangle i</td>
</tr>
<tr>
<td>Notes</td>
<td>NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third</br>[2,3].  this convention is DIFFERENT from cotmatrix_entries.h</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">triangulate</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="triangulatev-array-e-array-h-array-flags-str-a0005qq"><strong><code class="codehilite"><span class="n">triangulate</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="s1">&#39;a0.005qQ&#39;</span><span class="p">)</span></code></strong><a class="headerlink" href="#triangulatev-array-e-array-h-array-flags-str-a0005qq" title="Permanent link">&para;</a></h3>
<p>Triangulate the interior of a polygon using the triangle library.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>v : #v by 2 array of 2D vertex positions</br>e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon</br>h : #h by 2 coordinates of points contained inside holes of the polygon</br>m : optional #v list of markers for input vertices</br>flags : string of options pass to triangle (see triangle documentation) (default &lsquo;a0.005q&rsquo;)</td>
</tr>
<tr>
<td>Returns</td>
<td>v2 : #v2 by 2 coordinates of the vertives of the generated triangulation</br>f2 : #f2 by 3 array of indices forming the faces of the generated triangulation</br>m2 : (only if you passed in m) #v2 list of markers for output vertices</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span> <span class="n">v2</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">uniformly_sample_two_manifold_at_vertices</span> <span class="o">=</span> <span class="n">uniformly_sample_two_manifold_at_vertices</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float"><strong><code class="codehilite"><span class="n">uniformly_sample_two_manifold_at_vertices</span><span class="p">(</span><span class="n">ow</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">push</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span></code></strong><a class="headerlink" href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float" title="Permanent link">&para;</a></h3>
<p>Find uniform sampling up to placing samples on mesh vertices</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td></td>
</tr>
<tr>
<td>Returns</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">uniformly_sample_two_manifold_internal</span> <span class="o">=</span> <span class="n">uniformly_sample_two_manifold_internal</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float"><strong><code class="codehilite"><span class="n">uniformly_sample_two_manifold_internal</span><span class="p">(</span><span class="n">w</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">push</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span></code></strong><a class="headerlink" href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float" title="Permanent link">&para;</a></h3>
<p>UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by
furthest point relaxation as described in &ldquo;Fast Automatic Skinning
Transformations&rdquo;
[Jacobson et al. 12] Section 3.3.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>W  #W by dim positions of mesh in weight space</br>F  #F by 3 indices of triangles</br>k  number of samplse</br>push  factor by which corners should be pushed away</td>
</tr>
<tr>
<td>Returns</td>
<td>WS  k by dim locations in weights space</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">unproject</span> <span class="o">=</span> <span class="n">unproject</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="unprojectwin-array-model-array-proj-array-viewport-array"><strong><code class="codehilite"><span class="n">unproject</span><span class="p">(</span><span class="n">win</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">proj</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">viewport</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#unprojectwin-array-model-array-proj-array-viewport-array" title="Permanent link">&para;</a></h3>
<p>Reimplementation of gluUnproject</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>win  #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates</br>model  4x4 model-view matrix</br>proj  4x4 projection matrix</br>viewport  4-long viewport vector</td>
</tr>
<tr>
<td>Returns</td>
<td>scene  #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">unproject_in_mesh</span> <span class="o">=</span> <span class="n">unproject_in_mesh</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array"><strong><code class="codehilite"><span class="n">unproject_in_mesh</span><span class="p">(</span><span class="n">pos</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">float32</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">model</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">float32</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="n">proj</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">float32</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="n">viewport</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">float32</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array" title="Permanent link">&para;</a></h3>
<p>Unproject a screen location (using current opengl viewport, projection, and
model view) to a 3D position <em>inside</em> a given mesh. If the ray through the
given screen location (x,y) <em>hits</em> the mesh more than twice then the 3D
midpoint between the first two hits is return. If it hits once, then that
point is return. If it does not hit the mesh then obj is not set.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>pos        screen space coordinates</br>model      model matrix</br>proj       projection matrix</br>viewport   vieweport vector</br>V   #V by 3 list of mesh vertex positions</br>F   #F by 3 list of mesh triangle indices into V</td>
</tr>
<tr>
<td>Returns</td>
<td>obj        3d unprojected mouse point in mesh</br>hits       vector of hits</br>Returns number of hits</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">unproject_onto_mesh</span> <span class="o">=</span> <span class="n">unproject_onto_mesh</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array"><strong><code class="codehilite"><span class="n">unproject_onto_mesh</span><span class="p">(</span><span class="n">pos</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">proj</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">viewport</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array" title="Permanent link">&para;</a></h3>
<p>Unproject a screen location (using current opengl viewport, projection, and
model view) to a 3D position <em>onto</em> a given mesh, if the ray through the
given screen location (x,y) <em>hits</em> the mesh.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>pos        screen space coordinates</br>model      model matrix</br>proj       projection matrix</br>viewport   vieweport vector</br>V   #V by 3 list of mesh vertex positions</br>F   #F by 3 list of mesh triangle indices into V</td>
</tr>
<tr>
<td>Returns</td>
<td>fid  id of the first face hit</br>bc  barycentric coordinates of hit</br>Returns true if there&rsquo;s a hit</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">unproject_ray</span> <span class="o">=</span> <span class="n">unproject_ray</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="unproject_raypos-array-model-array-proj-array-viewport-array"><strong><code class="codehilite"><span class="n">unproject_ray</span><span class="p">(</span><span class="n">pos</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">proj</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">viewport</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#unproject_raypos-array-model-array-proj-array-viewport-array" title="Permanent link">&para;</a></h3>
<p>Construct a ray (source point + direction vector) given a screen space
positions (e.g. mouse) and a model-view projection constellation.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>pos  2d screen-space position (x,y)</br>model  4x4 model-view matrix</br>proj  4x4 projection matrix</br>viewport  4-long viewport vector</td>
</tr>
<tr>
<td>Returns</td>
<td>s  source of ray (pos unprojected with z=0)</br>dir  direction of ray (d - s) where d is pos unprojected with z=1</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">upsample</span> <span class="o">=</span> <span class="n">upsample</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="upsamplev-array-f-array-number_of_subdivs-int-1"><strong><code class="codehilite"><span class="n">upsample</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">number_of_subdivs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span></code></strong><a class="headerlink" href="#upsamplev-array-f-array-number_of_subdivs-int-1" title="Permanent link">&para;</a></h3>
<p>Subdivide a mesh without moving vertices: loop subdivision but odd
vertices stay put and even vertices are just edge midpoints</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  #V by dim  mesh vertices</br>F  #F by 3  mesh triangles</td>
</tr>
<tr>
<td>Returns</td>
<td>NV new vertex positions, V is guaranteed to be at top</br>NF new list of face indices</td>
</tr>
<tr>
<td>Notes</td>
<td>- assumes (V,F) is edge-manifold.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">vector_area_matrix</span> <span class="o">=</span> <span class="n">vector_area_matrix</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="vector_area_matrixf-array"><strong><code class="codehilite"><span class="n">vector_area_matrix</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#vector_area_matrixf-array" title="Permanent link">&para;</a></h3>
<p>Constructs the symmetric area matrix A, s.t. [V.col(0)&rsquo; V.col(1)&rsquo;] * A *
[V.col(0); V.col(1)] is the <strong>vector area</strong> of the mesh (V,F).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : #f by 3 array of mesh faces (must be triangles)</td>
</tr>
<tr>
<td>Returns</td>
<td>a : #vx2 by #vx2 area matrix</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">vertex_components</span> <span class="o">=</span> <span class="n">vertex_components</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="vertex_componentsf-array"><strong><code class="codehilite"><span class="n">vertex_components</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#vertex_componentsf-array" title="Permanent link">&para;</a></h3>
<p>Compute connected components of the vertices of a mesh given the mesh&rsquo; face indices.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>f : #f x dim array of face indices</td>
</tr>
<tr>
<td>Returns</td>
<td>An array of component ids (starting with 0)</td>
</tr>
<tr>
<td>See also</td>
<td>vertex_components_from_adjacency_matrix</br>face_components_from_faces</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">vertex_components_from_adjacency_matrix</span> <span class="o">=</span> <span class="n">vertex_components_from_adjacency_matrix</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="vertex_components_from_adjacency_matrixa-sparse_matrix"><strong><code class="codehilite"><span class="n">vertex_components_from_adjacency_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">sparse_matrix</span><span class="p">)</span></code></strong><a class="headerlink" href="#vertex_components_from_adjacency_matrixa-sparse_matrix" title="Permanent link">&para;</a></h3>
<p>Compute connected components of a graph represented by a sparse adjacency
matrix.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>a : n by n sparse adjacency matrix</td>
</tr>
<tr>
<td>Returns</td>
<td>A tuple (c, counts) where c is an array of component ids (starting with 0)</br>and counts is a #components array of counts for each component</td>
</tr>
<tr>
<td>See also</td>
<td>vertex_components</br>face_components</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">vertex_triangle_adjacency</span> <span class="o">=</span> <span class="n">vertex_triangle_adjacency</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="vertex_triangle_adjacencyf-array-n-int"><strong><code class="codehilite"><span class="n">vertex_triangle_adjacency</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong><a class="headerlink" href="#vertex_triangle_adjacencyf-array-n-int" title="Permanent link">&para;</a></h3>
<p>vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>F  #F by 3 list of triangle indices into some vertex list V</br>n  number of vertices, #V (e.g., F.maxCoeff()+1)</td>
</tr>
<tr>
<td>Returns</td>
<td>VF  3*#F list  List of faces indice on each vertex, so that VF(NI(i)+j) =</br>f, means that face f is the jth face (in no particular order) incident</br>on vertex i.</br>NI  #V+1 list  cumulative sum of vertex-triangle degrees with a</br>preceeding zero. &ldquo;How many faces&rdquo; have been seen before visiting this</br>vertex and its incident faces.</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">winding_number</span> <span class="o">=</span> <span class="n">winding_number</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="winding_numberv-array-f-array-o-array"><strong><code class="codehilite"><span class="n">winding_number</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">o</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span></code></strong><a class="headerlink" href="#winding_numberv-array-f-array-o-array" title="Permanent link">&para;</a></h3>
<p>WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron
described by points (vectors) V</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  n by 3 list of vertex positions</br>F  #F by 3 list of triangle indices, minimum index is 0</br>O  no by 3 list of origin positions</td>
</tr>
<tr>
<td>Returns</td>
<td>S  no by 1 list of winding numbers</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">winding_number_for_point</span> <span class="o">=</span> <span class="n">winding_number_for_point</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="winding_number_for_pointv-array-f-array-p-array-float"><strong><code class="codehilite"><span class="n">winding_number_for_point</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span></code></strong><a class="headerlink" href="#winding_number_for_pointv-array-f-array-p-array-float" title="Permanent link">&para;</a></h3>
<p>Compute winding number of a single point</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>V  n by dim list of vertex positions</br>F  #F by dim list of triangle indices, minimum index is 0</br>p  single origin position</td>
</tr>
<tr>
<td>Returns</td>
<td>w  winding number of this point</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">write_obj</span> <span class="o">=</span> <span class="n">write_obj</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="write_objfilename-str-v-array-f-array-bool"><strong><code class="codehilite"><span class="n">write_obj</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool</span></code></strong><a class="headerlink" href="#write_objfilename-str-v-array-f-array-bool" title="Permanent link">&para;</a></h3>
<p>Write a mesh in an ascii obj file.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>filename : path to outputfile</br>v : array of vertex positions #v by 3</br>f : #f list of face indices into vertex positions</td>
</tr>
<tr>
<td>Returns</td>
<td>ret : bool if output was successful</td>
</tr>
<tr>
<td>See also</td>
<td>read_obj</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="c1"># Mesh in (v, f)</span>
 <span class="n">success</span> <span class="o">=</span> <span class="n">write_obj</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">igl</span><span class="o">.</span><span class="n">write_off</span> <span class="o">=</span> <span class="n">write_off</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="write_offstr-str-v-array-f-array-c-array-bool"><strong><code class="codehilite"><span class="n">write_off</span><span class="p">(</span><span class="n">str</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="k">c</span><span class="p">:</span> <span class="nb">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool</span></code></strong><a class="headerlink" href="#write_offstr-str-v-array-f-array-c-array-bool" title="Permanent link">&para;</a></h3>
<p>Export geometry and colors-by-vertex
Export a mesh from an ascii OFF file, filling in vertex positions.
Only triangle meshes are supported</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>str  path to .off output file</br>V  #V by 3 mesh vertex positions</br>F  #F by 3 mesh indices into V</br>C  double matrix of rgb values per vertex #V by 3</td>
</tr>
<tr>
<td>Returns</td>
<td>Returns true on success, false on errors</td>
</tr>
</tbody>
</table>
<p><strong>Examples</strong>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">.</span><span class="n">write_triangle_mesh</span> <span class="o">=</span> <span class="n">write_triangle_mesh</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
</pre></div></p>
<h3 id="write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool"><strong><code class="codehilite"><span class="n">write_triangle_mesh</span><span class="p">(</span><span class="n">str</span><span class="p">:</span> <span class="n">str</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="nb">array</span><span class="p">,</span> <span class="n">force_ascii</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="k">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool</span></code></strong><a class="headerlink" href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool" title="Permanent link">&para;</a></h3>
<p>write mesh to a file with automatic detection of file format.  supported: obj, off, stl, wrl, ply, mesh).</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters</td>
<td>str  path to file</br>V  eigen double matrix #V by 3</br>F  eigen int matrix #F by 3</br>force_ascii=True  force ascii format even if binary is available</td>
</tr>
<tr>
<td>Returns</td>
<td>Returns true iff success</td>
</tr>
</tbody>
</table>
<h2 id="class-arap">class ARAP<a class="headerlink" href="#class-arap" title="Permanent link">&para;</a></h2>
<p><strong><code class="codehilite"><span class="n">solve</span><span class="p">(:</span> <span class="n">igl</span><span class="p">.</span><span class="n">pyigl_classes</span><span class="p">.</span><span class="n">ARAP</span><span class="p">,</span> <span class="n">arg0</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">arg1</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span></code></strong>
Static methods inherited from :</p>
<h2 id="class-bbw">class BBW<a class="headerlink" href="#class-bbw" title="Permanent link">&para;</a></h2>
<p><strong><code class="codehilite"><span class="n">solve</span><span class="p">(:</span> <span class="n">igl</span><span class="p">.</span><span class="n">pyigl_classes</span><span class="p">.</span><span class="n">BBW</span><span class="p">,</span> <span class="n">arg0</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">arg1</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">arg2</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">int32</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">arg3</span><span class="p">:</span> <span class="n">numpy</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span></code></strong>
Static methods inherited from :</p>
<h2 id="class-slim">class SLIM<a class="headerlink" href="#class-slim" title="Permanent link">&para;</a></h2>
<p><strong><code class="codehilite"><span class="n">energy</span><span class="p">(:</span> <span class="n">igl</span><span class="p">.</span><span class="n">pyigl_classes</span><span class="p">.</span><span class="n">SLIM</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span></code></strong></p>
<p><strong><code class="codehilite"><span class="n">solve</span><span class="p">(:</span> <span class="n">igl</span><span class="p">.</span><span class="n">pyigl_classes</span><span class="p">.</span><span class="n">SLIM</span><span class="p">,</span> <span class="n">arg0</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span></code></strong></p>
<p><strong><code class="codehilite"><span class="n">vertices</span><span class="p">(:</span> <span class="n">igl</span><span class="p">.</span><span class="n">pyigl_classes</span><span class="p">.</span><span class="n">SLIM</span><span class="p">)</span></code></strong>
Static methods inherited from :</p></article></div></div></main><footer class="md-footer"><div class="md-footer-nav"><nav class="md-footer-nav__inner md-grid"><a href="../tutorials/" title="Tutorial" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev"><div class="md-flex__cell md-flex__cell--shrink"><i class="md-icon md-icon--arrow-back md-footer-nav__button"></i></div><div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span class="md-flex__ellipsis"><span class="md-footer-nav__direction">Previous</span>Tutorial</span></div></a></nav></div><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class="md-footer-copyright">powered by <a href="https://www.mkdocs.org">MkDocs</a> and <a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a></div><div class="md-footer-social"><link rel="stylesheet" href="../assets/fonts/font-awesome.css"> <a href="https://github.com/geometryprocessing/libigl-python-bindings" class="md-footer-social__link fa fa-github"></a> </div></div></div></footer></div><script src="../assets/javascripts/application.b260a35d.js"></script><script>app.initialize({version:"1.0.4",url:{base:".."}})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>