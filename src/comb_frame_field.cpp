#include "default_types.h"
#include <igl/comb_frame_field.h>
#include <nanobind/nanobind.h>
#include <nanobind/ndarray.h>
#include <nanobind/eigen/dense.h>
#include <nanobind/stl/tuple.h>

namespace nb = nanobind;
using namespace nb::literals;

void bind_comb_frame_field(nb::module_ &m)
{
    m.def("comb_frame_field",
        [](
            const Eigen::MatrixXN& V,
            const Eigen::MatrixXI& F,
            const Eigen::MatrixXN& PD1,
            const Eigen::MatrixXN& PD2,
            const Eigen::MatrixXN& BIS1_combed,
            const Eigen::MatrixXN& BIS2_combed
        ) {
            Eigen::MatrixXN PD1_combed, PD2_combed;
            igl::comb_frame_field(V, F, PD1, PD2, BIS1_combed, BIS2_combed, PD1_combed, PD2_combed);
            return std::make_tuple(PD1_combed, PD2_combed);
        },
        "V"_a,
        "F"_a,
        "PD1"_a,
        "PD2"_a,
        "BIS1_combed"_a,
        "BIS2_combed"_a,
        R"(Computes principal matchings of the vectors of a frame field across face edges,
           and generates a combed frame field defined on the mesh faces. This makes use of a
           combed cross field generated by combing the field created by the bisectors of the
           frame field.
         
           @param[in] V            #V by 3 eigen Matrix of mesh vertex 3D positions
           @param[in] F            #F by 4 eigen Matrix of face (quad) indices
           @param[in] PD1          #F by 3 eigen Matrix of the first per face cross field vector
           @param[in] PD2          #F by 3 eigen Matrix of the second per face cross field vector
           @param[in] BIS1_combed  #F by 3 eigen Matrix of the first combed bisector field vector
           @param[in] BIS2_combed  #F by 3 eigen Matrix of the second combed bisector field vector
           @param[out] PD1_combed  #F by 3 eigen Matrix of the first combed cross field vector
           @param[out] PD2_combed  #F by 3 eigen Matrix of the second combed cross field vector
        )"
    );
}
